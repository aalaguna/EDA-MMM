# Config.R

# =============================================================================
# Global configuration of the EDA application.
# Defines options and loads the necessary libraries.
# =============================================================================

options(shiny.maxRequestSize = 30 * 1024^2)       # Upload limit set to 30 MB
options(future.globals.maxSize = 1000 * 1024^2)   # Handle large datasets
options(DT.options = list(pageLength = 25))
options(scipen = 999)                             # Avoid scientific notation
options(lubridate.week.start = 1)                 # Week starts on Monday

suppressPackageStartupMessages({
  library(shiny)
  library(dplyr)
  library(tidyr)
  library(ggplot2)
  library(corrplot)
  library(zoo)
  library(stringr)
  library(DT)
  library(plotly)
  library(shinyjs)
  library(gridExtra)
  library(scales)
  library(purrr)
  library(shinythemes)
  library(shinyWidgets)
})

theme_set(theme_minimal())
Sys.setlocale("LC_TIME", "en_US.UTF-8")
# Constants.R

# =============================================================================
# Constants used in the EDA application.
# =============================================================================

# A simple color palette for the application
app_colors <- c(
  "primary"   = "#0072B2",
  "secondary" = "#E69F00",
  "tertiary"  = "#009E73",
  "warning"   = "#D55E00",
  "info"      = "#56B4E9"
)
# Global_Functions.R

# =============================================================================
# Global functions used throughout the EDA application.
# =============================================================================

# Helper function to format numbers with K, M, B, etc.
format_num <- function(x) {
  # Formats a number with K, M, B suffixes for thousands, millions, and billions
  if (is.na(x)) return(NA)
  if (!is.numeric(x)) return(x)
  if (abs(x) >= 1e9) {
    sprintf("%.2fB", x / 1e9)
  } else if (abs(x) >= 1e6) {
    sprintf("%.2fM", x / 1e6)
  } else if (abs(x) >= 1e3) {
    sprintf("%.2fK", x / 1e3)
  } else {
    format(round(x, 2), big.mark = ",", scientific = FALSE)
  }
}

# Logging function
log_message <- function(message) {
  # Logs a message to the console with a timestamp
  cat(paste(Sys.time(), "- LOG:", message, "\n"))
}

# Error handler
error_handler <- function(e) {
  # Logs an error to the console with a timestamp
  cat(paste(Sys.time(), "- ERROR:", e$message, "\n"))
}

# Show notification and log
notifyUser <- function(message, type = "message", duration = 4) {
  # Displays a notification to the user and logs the message
  showNotification(message, type = type, duration = duration)
  log_message(message)
}
# Global.R

# =============================================================================
# Global configuration of the EDA application.
# Loads configurations, common functions, and constants.
# =============================================================================

# Load configurations
source("R/Config/Config.R", local = TRUE)
source("R/Config/Constants.R", local = TRUE)
source("R/Config/Global_functions.R", local = TRUE)

# Load common modules
source("R/Modules/Common/data_filtering.R", local = TRUE) 
source("R/Modules/Common/s_curve_helpers.R", local = TRUE)
source("R/Modules/Common/s_curve_charts.R", local = TRUE)

log_message("✅ global.R file loaded successfully.")
# Data_Filtering.R

# =============================================================================
# Common data filtering functions used throughout the application 
# (by geography and date).
# =============================================================================

filter_by_geography <- function(data, geography_input,
                                geo_col_names = c("Geography", "Geografia"),
                                total_value = "Total") {
  # Filters the dataframe by the selected geography
  # 
  # Args:
  #   data: Dataframe to filter
  #   geography_input: Selected geography value from user input
  #   geo_col_names: Possible names for the geography column
  #   total_value: Value that represents "Total" (sum all geographies)
  #
  # Returns:
  #   Filtered dataframe
  
  req(data, geography_input)
  geo_col <- intersect(geo_col_names, names(data))
  if (length(geo_col) > 0) {
    geo_col <- geo_col[1]
    if (geography_input != total_value && geography_input != "N/A") {
      data <- data %>% filter(.data[[geo_col]] == geography_input)
    } else if (geography_input == total_value) {
      # Group and sum data for all geographies by date
      date_col <- if ("Period" %in% names(data)) "Period" else if ("periodo" %in% names(data)) "periodo" else NULL
      if (!is.null(date_col)) {
        numeric_cols <- names(data)[sapply(data, is.numeric)]
        data <- data %>%
          group_by(across(all_of(date_col))) %>%
          summarise(across(all_of(numeric_cols), ~ sum(.x, na.rm = TRUE)), .groups = "drop")
      }
    }
  }
  return(data)
}

filter_by_date <- function(data, start_date, end_date) {
  # Filters the dataframe by date range
  #
  # Args:
  #   data: Dataframe to filter
  #   start_date: Start date
  #   end_date: End date
  #
  # Returns:
  #   Dataframe filtered by date range
  
  req(data)
  date_col <- if ("Period" %in% names(data)) "Period" else if ("periodo" %in% names(data)) "periodo" else NULL
  if (!is.null(date_col)) {
    data <- data %>%
      filter(
        as.Date(.data[[date_col]]) >= start_date,
        as.Date(.data[[date_col]]) <= end_date
      )
  }
  return(data)
}
# Download_Handler.R

# =============================================================================
# Configures the downloadHandler to export the transformed dataset,
# with robust validations.
# =============================================================================

download_handler_module <- function(input, output, session, rv) {
  # Sets up the download handler for the analytical file
  #
  # Args:
  #   input: Shiny input object
  #   output: Shiny output object
  #   session: Shiny session object
  #   rv: Shared reactive values
  
  output$download_analytical <- downloadHandler(
    filename = function() {
      paste0("analytical_transformed_", Sys.Date(), ".csv")
    },
    content = function(file) {
      tryCatch({
        download_data <- rv$filtered_data
        if (is.null(download_data) || nrow(download_data) == 0) {
          stop("No data available for download.")
        }
        
        # ---------------------------
        # UNIVARIATE TRANSFORMATION
        # ---------------------------
        if (!is.null(input$variable_univ) && input$variable_univ != "") {
          newcol <- paste0(input$variable_univ, "_transformed")
          download_data[[newcol]] <- apply_transformation(
            download_data[[input$variable_univ]],
            type   = input$transformation_univ,
            alpha  = input$alpha_univ,
            beta   = input$beta_univ,
            maxval = input$maxval_univ,
            decay  = input$decay_univ,
            lag    = input$lag_univ
          )
        }
        
        # --------------------------------
        # MULTIVARIATE TRANSFORMATION LOGIC
        # --------------------------------
        # If sum_all_vars is enabled, we transform each selected variable
        # using the respective transformation. Then (optionally) the user
        # can sum them for correlation. But in any case, we store them
        # as separate transformed columns.
        if (!is.null(input$sum_all_vars) && input$sum_all_vars == "true") {
          vars_to_transform <- c(input$var1_multi, input$var2_multi, input$var3_multi)
          if (!is.null(input$var4_multi) && input$var4_multi != "None" && input$var4_multi != "") {
            vars_to_transform <- c(vars_to_transform, input$var4_multi)
          }
          for (var_i in vars_to_transform) {
            if (!var_i %in% names(download_data)) next
            # Determine the selected transformation for each variable
            trans_type <- if (var_i == input$var1_multi) {
              input$trans_var1
            } else if (var_i == input$var2_multi) {
              input$trans_var2
            } else if (var_i == input$var3_multi) {
              input$trans_var3
            } else if (var_i == input$var4_multi) {
              input$trans_var4
            } else {
              "Linear"
            }
            newcol <- paste0(var_i, "_transformed")
            download_data[[newcol]] <- apply_transformation(
              download_data[[var_i]],
              type    = trans_type,
              alpha   = input$alpha_multi,
              beta    = input$beta_multi,
              maxval  = input$maxval_multi,
              decay   = input$decay_multi,
              lag     = input$lag_multi
            )
          }
        } else {
          # sum_all_vars == "false" => transform each variable individually
          # using trans_var1, trans_var2, etc.
          vars_ind <- c(input$var1_multi, input$var2_multi, input$var3_multi)
          if (!is.null(input$var4_multi) && input$var4_multi != "None") {
            vars_ind <- c(vars_ind, input$var4_multi)
          }
          for (var_i in vars_ind) {
            if (!var_i %in% names(download_data)) next
            trans_type <- if (var_i == input$var1_multi) {
              input$trans_var1
            } else if (var_i == input$var2_multi) {
              input$trans_var2
            } else if (var_i == input$var3_multi) {
              input$trans_var3
            } else if (var_i == input$var4_multi) {
              input$trans_var4
            } else {
              "Linear"
            }
            newcol <- paste0(var_i, "_transformed")
            download_data[[newcol]] <- apply_transformation(
              download_data[[var_i]],
              type    = trans_type,
              alpha   = input$alpha_multi,
              beta    = input$beta_multi,
              maxval  = input$maxval_multi,
              decay   = input$decay_multi,
              lag     = input$lag_multi
            )
          }
        }
        
        write.csv(download_data, file, row.names = FALSE, na = "")
        notifyUser("Transformed data file downloaded.", "message", duration = 3)
        
      }, error = function(e) {
        notifyUser(paste("Download error:", e$message), "error")
      })
    }
  )
}
# Download_Transformed_Handler.R

# =============================================================================
# Manejadores de descarga para datos transformados en módulos univariado y multivariado
# =============================================================================

# Manejador para descargar datos transformados en módulo univariado
univariate_download_handler <- function(input, output, session, rv) {
  # Configura el manejador de descarga para datos transformados univariados
  #
  # Args:
  #   input: Objeto input de Shiny
  #   output: Objeto output de Shiny
  #   session: Objeto session de Shiny
  #   rv: Valores reactivos compartidos
  
  output$download_univariate <- downloadHandler(
    filename = function() {
      # Generar nombre de archivo con variable, transformación y fecha
      variable_name <- ifelse(is.null(input$variable_univ) || input$variable_univ == "N/A", 
                             "variable", 
                             gsub("[^a-zA-Z0-9]", "_", input$variable_univ))
      trans_type <- gsub(" ", "_", input$transformation_univ)
      paste0("univariate_", variable_name, "_", trans_type, "_", Sys.Date(), ".csv")
    },
    content = function(file) {
      tryCatch({
        withProgress(message = 'Preparing download...', value = 0.1, {
          # Obtener datos filtrados
          data <- rv$filtered_data
          if (is.null(data) || nrow(data) == 0) {
            stop("No hay datos disponibles para descargar.")
          }
          
          # Convertir la columna de fecha antes de filtrar
          if ("Period" %in% names(data)) {
            data$Period <- as.Date(data$Period)
          } else if ("periodo" %in% names(data)) {
            data$periodo <- as.Date(data$periodo)
          }
          
          # Aplicar filtro de fecha si está disponible
          if (!is.null(input$date_range_univ)) {
            date_col <- if ("Period" %in% names(data)) "Period" else if ("periodo" %in% names(data)) "periodo" else NULL
            if (!is.null(date_col)) {
              data <- data[data[[date_col]] >= input$date_range_univ[1] & 
                          data[[date_col]] <= input$date_range_univ[2], ]
            }
          }
          
          # Filtrar por geografía si es necesario
          if (!is.null(input$geography_univ) && input$geography_univ != "N/A") {
            geo_col <- if ("Geography" %in% names(data)) "Geography" else if ("Geografia" %in% names(data)) "Geografia" else NULL
            if (!is.null(geo_col) && input$geography_univ != "Total") {
              data <- data %>% filter(.data[[geo_col]] == input$geography_univ)
            } else if (input$geography_univ == "Total") {
              # Manejar caso "Total" - agrupar y sumar datos
              date_col <- if ("Period" %in% names(data)) "Period" else if ("periodo" %in% names(data)) "periodo" else NULL
              if (!is.null(date_col)) {
                numeric_cols <- names(data)[sapply(data, is.numeric)]
                data <- data %>%
                  group_by(across(all_of(date_col))) %>%
                  summarise(across(all_of(numeric_cols), ~ sum(.x, na.rm = TRUE)), .groups = "drop")
              }
            }
          }
          
          # Aplicar filtros adicionales si están disponibles (producto, campaña, etc.)
          if (!is.null(input$product_univ) && input$product_univ != "N/A") {
            prod_col <- if ("Product" %in% names(data)) "Product" else if ("Producto" %in% names(data)) "Producto" else NULL
            if (!is.null(prod_col)) {
              data <- data %>% filter(.data[[prod_col]] == input$product_univ)
            }
          }
          
          if (!is.null(input$campaign_univ) && input$campaign_univ != "N/A") {
            camp_col <- if ("Campaign" %in% names(data)) "Campaign" else if ("Campaña" %in% names(data)) "Campaña" else NULL
            if (!is.null(camp_col)) {
              data <- data %>% filter(.data[[camp_col]] == input$campaign_univ)
            }
          }
          
          if (!is.null(input$outlet_univ) && input$outlet_univ != "N/A") {
            outlet_col <- if ("Outlet" %in% names(data)) "Outlet" else NULL
            if (!is.null(outlet_col)) {
              data <- data %>% filter(.data[[outlet_col]] == input$outlet_univ)
            }
          }
          
          if (!is.null(input$creative_univ) && input$creative_univ != "N/A") {
            creative_col <- if ("Creative" %in% names(data)) "Creative" else if ("Creativo" %in% names(data)) "Creativo" else NULL
            if (!is.null(creative_col)) {
              data <- data %>% filter(.data[[creative_col]] == input$creative_univ)
            }
          }
          
          incProgress(0.3)
          
          # Verificar que existe la variable seleccionada
          if (is.null(input$variable_univ) || !(input$variable_univ %in% names(data))) {
            stop("La variable seleccionada no está disponible en los datos.")
          }
          
          # Aplicar transformación
          var_data <- data[[input$variable_univ]]
          transformed_data <- apply_transformation(
            var_data,
            type    = input$transformation_univ,
            alpha   = input$alpha_univ,
            beta    = input$beta_univ,
            maxval  = input$maxval_univ,
            decay   = input$decay_univ,
            lag     = input$lag_univ
          )
          
          incProgress(0.3)
          
          # Crear nombre para la columna transformada
          trans_col_name <- paste0(input$variable_univ, "_", gsub(" ", "_", input$transformation_univ))
          
          # Añadir la columna transformada al dataframe
          data[[trans_col_name]] <- transformed_data
          
          # Seleccionar solo las columnas necesarias para la descarga
          date_col <- if ("Period" %in% names(data)) "Period" else if ("periodo" %in% names(data)) "periodo" else NULL
          
          download_cols <- c(date_col, input$variable_univ, trans_col_name)
          # Agregar KPI si está seleccionado
          if (!is.null(input$kpi_univ) && input$kpi_univ != "N/A" && input$kpi_univ %in% names(data)) {
            download_cols <- c(download_cols, input$kpi_univ)
          }
          
          # Filtrar solo las columnas seleccionadas
          download_data <- data[, download_cols, drop = FALSE]
          
          # Añadir metadatos sobre la transformación
          metadata <- data.frame(
            Parametro = c("Variable", "Transformación", "Alpha", "Beta", "Max Value %", "Decay", "Lag", "Fecha Inicio", "Fecha Fin", "Fecha Descarga"),
            Valor = c(
              input$variable_univ,
              input$transformation_univ,
              input$alpha_univ,
              input$beta_univ,
              input$maxval_univ,
              input$decay_univ,
              input$lag_univ,
              ifelse(!is.null(input$date_range_univ), as.character(input$date_range_univ[1]), NA),
              ifelse(!is.null(input$date_range_univ), as.character(input$date_range_univ[2]), NA),
              as.character(Sys.Date())
            )
          )
          
          incProgress(0.2)
          
          # Escribir datos y metadatos a archivos separados
          write.csv(download_data, file, row.names = FALSE, na = "")
          
          # Crear archivo de metadatos con el mismo nombre pero con sufijo _metadata
          metadata_file <- sub("\\.csv$", "_metadata.csv", file)
          write.csv(metadata, metadata_file, row.names = FALSE)
          
          incProgress(0.1)
        })
        
        notifyUser("Archivo de datos transformados univariados descargado correctamente.", "message", duration = 4)
        
      }, error = function(e) {
        notifyUser(paste("Error en la descarga de datos univariados:", e$message), "error", duration = 5)
      })
    }
  )
}

# Manejador para descargar datos transformados en módulo multivariado
multivariate_download_handler <- function(input, output, session, rv) {
  # Configura los manejadores de descarga para datos transformados multivariados
  # (modo suma y modo individual)
  #
  # Args:
  #   input: Objeto input de Shiny
  #   output: Objeto output de Shiny
  #   session: Objeto session de Shiny
  #   rv: Valores reactivos compartidos
  
  # 1. Manejador para modo suma
  output$download_multivariate_sum <- downloadHandler(
    filename = function() {
      paste0("multivariate_summed_", Sys.Date(), ".csv")
    },
    content = function(file) {
      tryCatch({
        withProgress(message = 'Preparing summed data download...', value = 0.1, {
          # Obtener datos filtrados
          data <- rv$filtered_data
          if (is.null(data) || nrow(data) == 0) {
            stop("No hay datos disponibles para descargar.")
          }
          
          # Convertir la columna de fecha antes de filtrar
          if ("Period" %in% names(data)) {
            data$Period <- as.Date(data$Period)
          } else if ("periodo" %in% names(data)) {
            data$periodo <- as.Date(data$periodo)
          }
          
          # Aplicar filtro de fecha si está disponible
          if (!is.null(input$date_range_multi)) {
            date_col <- if ("Period" %in% names(data)) "Period" else if ("periodo" %in% names(data)) "periodo" else NULL
            if (!is.null(date_col)) {
              data <- data[data[[date_col]] >= input$date_range_multi[1] & 
                          data[[date_col]] <= input$date_range_multi[2], ]
            }
          }
          
          # Filtrar por geografía si es necesario
          if (!is.null(input$geography_multi) && input$geography_multi != "N/A") {
            geo_col <- if ("Geography" %in% names(data)) "Geography" else if ("Geografia" %in% names(data)) "Geografia" else NULL
            if (!is.null(geo_col) && input$geography_multi != "Total") {
              data <- data %>% filter(.data[[geo_col]] == input$geography_multi)
            } else if (input$geography_multi == "Total") {
              # Manejar caso "Total" - agrupar y sumar datos
              date_col <- if ("Period" %in% names(data)) "Period" else if ("periodo" %in% names(data)) "periodo" else NULL
              if (!is.null(date_col)) {
                numeric_cols <- names(data)[sapply(data, is.numeric)]
                data <- data %>%
                  group_by(across(all_of(date_col))) %>%
                  summarise(across(all_of(numeric_cols), ~ sum(.x, na.rm = TRUE)), .groups = "drop")
              }
            }
          }
          
          # Aplicar filtros adicionales (producto, campaña, etc.)
          if (!is.null(input$product_multi) && input$product_multi != "N/A") {
            prod_col <- if ("Product" %in% names(data)) "Product" else if ("Producto" %in% names(data)) "Producto" else NULL
            if (!is.null(prod_col)) {
              data <- data %>% filter(.data[[prod_col]] == input$product_multi)
            }
          }
          
          if (!is.null(input$campaign_multi) && input$campaign_multi != "N/A") {
            camp_col <- if ("Campaign" %in% names(data)) "Campaign" else if ("Campaña" %in% names(data)) "Campaña" else NULL
            if (!is.null(camp_col)) {
              data <- data %>% filter(.data[[camp_col]] == input$campaign_multi)
            }
          }
          
          if (!is.null(input$outlet_multi) && input$outlet_multi != "N/A") {
            outlet_col <- if ("Outlet" %in% names(data)) "Outlet" else NULL
            if (!is.null(outlet_col)) {
              data <- data %>% filter(.data[[outlet_col]] == input$outlet_multi)
            }
          }
          
          if (!is.null(input$creative_multi) && input$creative_multi != "N/A") {
            creative_col <- if ("Creative" %in% names(data)) "Creative" else if ("Creativo" %in% names(data)) "Creativo" else NULL
            if (!is.null(creative_col)) {
              data <- data %>% filter(.data[[creative_col]] == input$creative_multi)
            }
          }
          
          incProgress(0.2)
          
          # Identificar variables seleccionadas
          vars_selected <- c()
          if (!is.null(input$var1_multi) && input$var1_multi != "None") {
            vars_selected <- c(vars_selected, input$var1_multi)
          }
          if (!is.null(input$var2_multi) && input$var2_multi != "None") {
            vars_selected <- c(vars_selected, input$var2_multi)
          }
          if (!is.null(input$var3_multi) && input$var3_multi != "None") {
            vars_selected <- c(vars_selected, input$var3_multi)
          }
          if (!is.null(input$var4_multi) && input$var4_multi != "None") {
            vars_selected <- c(vars_selected, input$var4_multi)
          }
          
          vars_selected <- intersect(vars_selected, names(data))
          
          if (length(vars_selected) < 1) {
            stop("No hay variables válidas seleccionadas para la transformación.")
          }
          
          incProgress(0.2)
          
          # Calcular suma de variables
          data$sum_vars <- rowSums(data[, vars_selected, drop = FALSE], na.rm = TRUE)
          
          # Aplicar transformación a la suma
          data$trans_sum_vars <- apply_transformation(
            data$sum_vars,
            type    = input$trans_var1,
            alpha   = input$alpha_multi,
            beta    = input$beta_multi,
            maxval  = input$maxval_multi,
            decay   = input$decay_multi,
            lag     = input$lag_multi
          )
          
          incProgress(0.3)
          
          # Seleccionar solo las columnas necesarias para la descarga
          date_col <- if ("Period" %in% names(data)) "Period" else if ("periodo" %in% names(data)) "periodo" else NULL
          
          download_cols <- c(date_col, vars_selected, "sum_vars", "trans_sum_vars")
          # Agregar KPI si está seleccionado
          if (!is.null(input$kpi_multi) && input$kpi_multi != "None" && input$kpi_multi %in% names(data)) {
            download_cols <- c(download_cols, input$kpi_multi)
          }
          
          # Filtrar solo las columnas seleccionadas
          download_data <- data[, download_cols, drop = FALSE]
          
          # Crear metadatos para la transformación
          metadata <- data.frame(
            Parametro = c(
              "Variables Sumadas",
              "Transformación",
              "Alpha",
              "Beta",
              "Max Value %",
              "Decay",
              "Lag",
              "Fecha Inicio",
              "Fecha Fin",
              "Fecha Descarga"
            ),
            Valor = c(
              paste(vars_selected, collapse = ", "),
              ifelse(!is.null(input$trans_var1), input$trans_var1, "Linear"),
              ifelse(!is.null(input$alpha_multi), input$alpha_multi, NA),
              ifelse(!is.null(input$beta_multi), input$beta_multi, NA),
              ifelse(!is.null(input$maxval_multi), input$maxval_multi, NA),
              ifelse(!is.null(input$decay_multi), input$decay_multi, NA),
              ifelse(!is.null(input$lag_multi), input$lag_multi, NA),
              ifelse(!is.null(input$date_range_multi), as.character(input$date_range_multi[1]), NA),
              ifelse(!is.null(input$date_range_multi), as.character(input$date_range_multi[2]), NA),
              as.character(Sys.Date())
            )
          )
          
          incProgress(0.2)
          
          # Escribir datos y metadatos
          write.csv(download_data, file, row.names = FALSE, na = "")
          
          # Crear archivo de metadatos con el mismo nombre pero con sufijo _metadata
          metadata_file <- sub("\\.csv$", "_metadata.csv", file)
          write.csv(metadata, metadata_file, row.names = FALSE)
          
          incProgress(0.1)
        })
        
        notifyUser("Archivo de datos transformados multivariados (suma) descargado correctamente.", "message", duration = 4)
        
      }, error = function(e) {
        notifyUser(paste("Error en la descarga de datos multivariados (suma):", e$message), "error", duration = 5)
      })
    }
  )
  
  # 2. Manejador para modo individual
  output$download_multivariate_individual <- downloadHandler(
    filename = function() {
      paste0("multivariate_individual_", Sys.Date(), ".csv")
    },
    content = function(file) {
      tryCatch({
        withProgress(message = 'Preparing individual data download...', value = 0.1, {
          # Obtener datos filtrados
          data <- rv$filtered_data
          if (is.null(data) || nrow(data) == 0) {
            stop("No hay datos disponibles para descargar.")
          }
          
          # Convertir la columna de fecha antes de filtrar
          if ("Period" %in% names(data)) {
            data$Period <- as.Date(data$Period)
          } else if ("periodo" %in% names(data)) {
            data$periodo <- as.Date(data$periodo)
          }
          
          # Aplicar filtro de fecha si está disponible
          if (!is.null(input$date_range_multi)) {
            date_col <- if ("Period" %in% names(data)) "Period" else if ("periodo" %in% names(data)) "periodo" else NULL
            if (!is.null(date_col)) {
              data <- data[data[[date_col]] >= input$date_range_multi[1] & 
                          data[[date_col]] <= input$date_range_multi[2], ]
            }
          }
          
          # Filtrar por geografía si es necesario
          if (!is.null(input$geography_multi) && input$geography_multi != "N/A") {
            geo_col <- if ("Geography" %in% names(data)) "Geography" else if ("Geografia" %in% names(data)) "Geografia" else NULL
            if (!is.null(geo_col) && input$geography_multi != "Total") {
              data <- data %>% filter(.data[[geo_col]] == input$geography_multi)
            } else if (input$geography_multi == "Total") {
              # Manejar caso "Total" - agrupar y sumar datos
              date_col <- if ("Period" %in% names(data)) "Period" else if ("periodo" %in% names(data)) "periodo" else NULL
              if (!is.null(date_col)) {
                numeric_cols <- names(data)[sapply(data, is.numeric)]
                data <- data %>%
                  group_by(across(all_of(date_col))) %>%
                  summarise(across(all_of(numeric_cols), ~ sum(.x, na.rm = TRUE)), .groups = "drop")
              }
            }
          }
          
          # Aplicar filtros adicionales
          if (!is.null(input$product_multi) && input$product_multi != "N/A") {
            prod_col <- if ("Product" %in% names(data)) "Product" else if ("Producto" %in% names(data)) "Producto" else NULL
            if (!is.null(prod_col)) {
              data <- data %>% filter(.data[[prod_col]] == input$product_multi)
            }
          }
          
          if (!is.null(input$campaign_multi) && input$campaign_multi != "N/A") {
            camp_col <- if ("Campaign" %in% names(data)) "Campaign" else if ("Campaña" %in% names(data)) "Campaña" else NULL
            if (!is.null(camp_col)) {
              data <- data %>% filter(.data[[camp_col]] == input$campaign_multi)
            }
          }
          
          if (!is.null(input$outlet_multi) && input$outlet_multi != "N/A") {
            outlet_col <- if ("Outlet" %in% names(data)) "Outlet" else NULL
            if (!is.null(outlet_col)) {
              data <- data %>% filter(.data[[outlet_col]] == input$outlet_multi)
            }
          }
          
          if (!is.null(input$creative_multi) && input$creative_multi != "N/A") {
            creative_col <- if ("Creative" %in% names(data)) "Creative" else if ("Creativo" %in% names(data)) "Creativo" else NULL
            if (!is.null(creative_col)) {
              data <- data %>% filter(.data[[creative_col]] == input$creative_multi)
            }
          }
          
          incProgress(0.2)
          
          # Identificar variables seleccionadas
          vars_selected <- c()
          if (!is.null(input$var1_multi) && input$var1_multi != "None") {
            vars_selected <- c(vars_selected, input$var1_multi)
          }
          if (!is.null(input$var2_multi) && input$var2_multi != "None") {
            vars_selected <- c(vars_selected, input$var2_multi)
          }
          if (!is.null(input$var3_multi) && input$var3_multi != "None") {
            vars_selected <- c(vars_selected, input$var3_multi)
          }
          if (!is.null(input$var4_multi) && input$var4_multi != "None") {
            vars_selected <- c(vars_selected, input$var4_multi)
          }
          
          vars_selected <- intersect(vars_selected, names(data))
          
          if (length(vars_selected) < 1) {
            stop("No hay variables válidas seleccionadas para la descarga.")
          }
          
          incProgress(0.3)
          
          # Seleccionar columnas para descarga
          date_col <- if ("Period" %in% names(data)) "Period" else if ("periodo" %in% names(data)) "periodo" else NULL
          
          download_cols <- c(date_col, vars_selected)
          # Agregar KPI si está seleccionado
          if (!is.null(input$kpi_multi) && input$kpi_multi != "None" && input$kpi_multi %in% names(data)) {
            download_cols <- c(download_cols, input$kpi_multi)
          }
          
          # Filtrar solo las columnas seleccionadas
          download_data <- data[, download_cols, drop = FALSE]
          
          # Crear metadatos simples
          metadata <- data.frame(
            Parametro = c(
              "Variables Seleccionadas",
              "Fecha Inicio",
              "Fecha Fin",
              "Fecha Descarga"
            ),
            Valor = c(
              paste(vars_selected, collapse = ", "),
              ifelse(!is.null(input$date_range_multi), as.character(input$date_range_multi[1]), NA),
              ifelse(!is.null(input$date_range_multi), as.character(input$date_range_multi[2]), NA),
              as.character(Sys.Date())
            )
          )
          
          incProgress(0.2)
          
          # Escribir datos y metadatos
          write.csv(download_data, file, row.names = FALSE, na = "")
          
          # Crear archivo de metadatos con el mismo nombre pero con sufijo _metadata
          metadata_file <- sub("\\.csv$", "_metadata.csv", file)
          write.csv(metadata, metadata_file, row.names = FALSE)
          
          incProgress(0.1)
        })
        
        notifyUser("Archivo de datos individuales descargado correctamente.", "message", duration = 4)
        
      }, error = function(e) {
        notifyUser(paste("Error en la descarga de datos multivariados (individuales):", e$message), "error", duration = 5)
      })
    }
  )
}# Global_Filters.R

# =============================================================================
# Updates selectInputs and global controls based on dataset columns,
# including additional filters for Product, Campaign, Outlet, and Creative.
# =============================================================================

extract_metric_info <- function(data) {
  # Extracts metric information from dataframe columns
  #
  # Args:
  #   data: Dataframe with data
  #
  # Returns:
  #   Dataframe with detailed information for each metric column
  
  # Identify only numeric columns
  metric_cols <- setdiff(names(data), c("Geography", "Geografia", "Period", "periodo"))
  metric_cols <- metric_cols[sapply(data[metric_cols], is.numeric)]
  
  info_list <- lapply(metric_cols, function(col) {
    parts <- unlist(str_split(col, "_"))
    if (length(parts) == 5) {
      return(data.frame(
        colname   = col,
        variable  = parts[1],
        product   = parts[2],
        campaign  = parts[3],
        outlet    = parts[4],
        creative  = parts[5],
        stringsAsFactors = FALSE
      ))
    } else {
      # If it doesn't have 5 parts, still include it
      return(data.frame(
        colname   = col,
        variable  = parts[1],
        product   = NA,
        campaign  = NA,
        outlet    = NA,
        creative  = NA,
        stringsAsFactors = FALSE
      ))
    }
  })
  info_df <- do.call(rbind, info_list)
  return(info_df)
}

update_global_filters <- function(data, input, session) {
  # Updates all global filters based on the loaded dataframe
  #
  # Args:
  #   data: Dataframe with data
  #   input: Shiny input object
  #   session: Shiny session object
  
  req(data)
  
  # Identify numeric columns
  numeric_cols <- names(data)[sapply(data, is.numeric)]
  
  # Possible media and cost variables
  media_keywords <- c("Impressions", "Circulation", "Clicks", 'Views', 
                      'Attendance', 'Dispatch', 'Delivered', 'Open', 
                      'Opened', 'GRPs', 'Sent', 'Sents',
                      "Display", "OOH", "OLV", "Magazine", "Newspaper")
  spend_keywords <- c("Cost", "Spend")
  competitors_to_exclude = c('Adthena', 'Kantar', 'Nielsen', 'Vivvix', 'Pathmathics')
  words_to_exclude = c('Day', 'Sentiment')
  
  
  MEDIA_VARIABLES <- grep(paste(media_keywords, collapse = "|"), names(data), value = TRUE, ignore.case = TRUE)
  MEDIA_VARIABLES <- grep(paste(competitors_to_exclude, collapse = "|"), MEDIA_VARIABLES, value = TRUE, ignore.case = TRUE, invert = TRUE)
  MEDIA_VARIABLES <- grep(paste(words_to_exclude, collapse = "|"), MEDIA_VARIABLES, value = TRUE, ignore.case = TRUE, invert = TRUE)
  SPEND_VARIABLES <- grep(paste(spend_keywords, collapse = "|"), MEDIA_VARIABLES, value = TRUE, ignore.case = TRUE)
  
  MEDIA_VARIABLES <- setdiff(MEDIA_VARIABLES, SPEND_VARIABLES)
  MEDIA_VARIABLES <- intersect(MEDIA_VARIABLES, numeric_cols)
  SPEND_VARIABLES <- intersect(SPEND_VARIABLES, numeric_cols)
  
  # Update KPI
  updateSelectInput(session, "kpi", choices = numeric_cols, selected = NULL)
  
  # # Update Media / Spend / Base
  # updateSelectInput(session, "media_vars", choices = MEDIA_VARIABLES, selected = MEDIA_VARIABLES)
  # updateSelectInput(session, "spend_vars", choices = SPEND_VARIABLES, selected = SPEND_VARIABLES)
  # updateSelectInput(session, "base_vars",  choices = numeric_cols,   selected = NULL)
  # 
  # Update Media / Spend / Base
  updateSelectizeInput(session, "media_vars", choices = MEDIA_VARIABLES, selected = MEDIA_VARIABLES, 
                       options = list(plugins = list("remove_button")))
  updateSelectizeInput(session, "spend_vars", choices = SPEND_VARIABLES, selected = SPEND_VARIABLES, 
                       options = list(plugins = list("remove_button")))
  updateSelectizeInput(session, "base_vars", choices = numeric_cols, selected = NULL, 
                       options = list(plugins = list("remove_button")))
  
  # Univariate panel: KPI
  updateSelectInput(session, "kpi_univ", choices = numeric_cols, selected = NULL)
  
  # Multivariate panel
  # Add "None" as the first option and set it as the default selection
  updateSelectInput(session, "kpi_multi",    choices = c("None", numeric_cols), selected = "None")
  updateSelectInput(session, "var1_multi",   choices = c("None", numeric_cols), selected = "None")
  updateSelectInput(session, "var2_multi",   choices = c("None", numeric_cols), selected = "None")
  updateSelectInput(session, "var3_multi",   choices = c("None", numeric_cols), selected = "None")
  updateSelectInput(session, "var4_multi",   choices = c("None", numeric_cols), selected = "None")
  
  # Metrics
  metric_info <- extract_metric_info(data)
  if (!is.null(metric_info) && nrow(metric_info) > 0) {
    updateSelectInput(session, "variable_univ", choices = metric_info$colname, selected = NULL)
    updateSelectInput(session, "product_univ",  choices = c("N/A", sort(unique(metric_info$product))),   selected = "N/A")
    updateSelectInput(session, "campaign_univ", choices = c("N/A", sort(unique(metric_info$campaign))), selected = "N/A")
    updateSelectInput(session, "outlet_univ",   choices = c("N/A", sort(unique(metric_info$outlet))),   selected = "N/A")
    updateSelectInput(session, "creative_univ", choices = c("N/A", sort(unique(metric_info$creative))), selected = "N/A")
    
    updateSelectInput(session, "product_multi",  choices = c("N/A", sort(unique(metric_info$product))),   selected = "N/A")
    updateSelectInput(session, "campaign_multi", choices = c("N/A", sort(unique(metric_info$campaign))), selected = "N/A")
    updateSelectInput(session, "outlet_multi",   choices = c("N/A", sort(unique(metric_info$outlet))),   selected = "N/A")
    updateSelectInput(session, "creative_multi", choices = c("N/A", sort(unique(metric_info$creative))), selected = "N/A")
  } else {
    # If there is no metric_info, set everything to "N/A"
    updateSelectInput(session, "variable_univ", choices = c("N/A"), selected = "N/A")
    updateSelectInput(session, "product_univ",  choices = c("N/A"), selected = "N/A")
    updateSelectInput(session, "campaign_univ", choices = c("N/A"), selected = "N/A")
    updateSelectInput(session, "outlet_univ",   choices = c("N/A"), selected = "N/A")
    updateSelectInput(session, "creative_univ", choices = c("N/A"), selected = "N/A")
    
    updateSelectInput(session, "product_multi",  choices = c("N/A"), selected = "N/A")
    updateSelectInput(session, "campaign_multi", choices = c("N/A"), selected = "N/A")
    updateSelectInput(session, "outlet_multi",   choices = c("N/A"), selected = "N/A")
    updateSelectInput(session, "creative_multi", choices = c("N/A"), selected = "N/A")
  }
  
  # Geography
  if ("Geography" %in% names(data) || "Geografia" %in% names(data)) {
    geo_col <- if ("Geography" %in% names(data)) "Geography" else "Geografia"
    geos <- sort(unique(data[[geo_col]]))
    choices <- c("Total", geos)
    updateSelectInput(session, "geography_univ",  choices = choices, selected = "Total")
    updateSelectInput(session, "geography_multi", choices = choices, selected = "Total")
    notifyUser("Geography filters updated.", "message", duration = 4)
  } else {
    notifyUser("Column 'Geography' or 'Geografia' not found. Geography filters not updated.", "warning", duration = 6)
  }
  
  notifyUser("SelectInputs updated with dataset columns.", "message", duration = 4)}
# S_Curve_Charts.R


# Module for creating Flighting and S-Curve Charts using Plotly

source("R/modules/common/s_curve_helpers.R")
library(plotly)
library(dplyr)

# -------------------------------------------------------------------------
# create_flighting_chart():
#   - Shows time series with 6 horizontal lines
#   - Includes 5 colored zones
# -------------------------------------------------------------------------
create_flighting_chart <- function(data_chart, alpha, beta, max_val_pct, decay = 1, lag = 0, var_name = "Variable",
                               calculated_key_points = NULL, avg_period = 52, avg_data = NULL) {
 
  if (!is.data.frame(data_chart) || !all(c("Period", "value") %in% names(data_chart))) {
    return(plot_ly() %>% layout(title = "Invalid data for Flighting Chart."))
  }
  if (nrow(data_chart) < 1) {
    return(plot_ly() %>% layout(title = "No rows for Flighting Chart."))
  }
 
  if (!is.numeric(data_chart$value)) {
    return(plot_ly() %>% layout(title = "The 'value' column is not numeric."))
  }
 
  # Keep original data but filter out zeros for calculations
  var_activity <- data_chart
  
  # Filter out zero values for calculations but keep them for display
  var_activity_no_zeros <- var_activity %>%
    filter(value > 0)
 
  # For percentiles ignore NA but include non-zero values
  val_no_na <- var_activity_no_zeros$value[!is.na(var_activity_no_zeros$value)]
  if (length(val_no_na) == 0) {
    return(plot_ly() %>% layout(title = "All values are NA in Flighting Chart."))
  }
 
  # Real maximum of the activity
  max_activity <- max(val_no_na, na.rm = TRUE)
  if (!is.finite(max_activity) || max_activity == 0) max_activity <- 1
 
  # Calculate "Max_value" based on max_val_pct
  Max_value <- max_activity * (max_val_pct / 100)
  
  # Calculate average from avg_data, ignoring zeros
  if (!is.null(avg_data) && nrow(avg_data) > 0) {
    avg_data_no_zeros <- avg_data %>%
      filter(value > 0)
    
    if (nrow(avg_data_no_zeros) > 0) {
      real_avg_period <- mean(avg_data_no_zeros$value, na.rm = TRUE)
      if (is.na(real_avg_period)) real_avg_period <- 0
      avg_period <- nrow(avg_data_no_zeros)  # Update avg_period to number of rows in filtered avg_data
    } else {
      # If no non-zero data in range, use default calculation
      real_avg_period <- mean(var_activity_no_zeros$value, na.rm = TRUE)
      if (is.na(real_avg_period)) real_avg_period <- 0
    }
  } else {
    # If no avg_data provided, calculate from non-zero values in var_activity
    real_avg_period <- mean(var_activity_no_zeros$value, na.rm = TRUE)
    if (is.na(real_avg_period)) real_avg_period <- 0
  }
 
  # If key points were provided from S-Curve, use those
  if (!is.null(calculated_key_points)) {
    avg_key_point <- paste0(avg_period, "_Period_Avg")
    # Make sure the key point exists
    if (avg_key_point %in% calculated_key_points$Key_point) {
      reference_lines <- data.frame(
        Key_point = c(avg_key_point, "Breakthrough", "Optimal begins",
                    "Saturation begins", "Full saturation", "Max efficiency"),
        Value = c(
          calculated_key_points$Value[calculated_key_points$Key_point == avg_key_point],
          calculated_key_points$Value[calculated_key_points$Key_point == "Breakthrough"],
          calculated_key_points$Value[calculated_key_points$Key_point == "Optimal begins"],
          calculated_key_points$Value[calculated_key_points$Key_point == "Saturation begins"],
          calculated_key_points$Value[calculated_key_points$Key_point == "Full saturation"],
          calculated_key_points$Value[calculated_key_points$Key_point == "Max efficiency"]
        ),
        Color = c("#4DAF4A", "#377EB8", "#000000", "#FF69B4", "#E41A1C", "#FFD700")
      )
    } else {
      # If it doesn't exist, calculate manually
      X_ratio <- min(max(real_avg_period / max_activity, 0), 1)
      exact_X_avg <- X_ratio * Max_value
      
      if (exact_X_avg < 0.001) exact_X_avg <- 0.001
      if (exact_X_avg > Max_value * 0.999) exact_X_avg <- Max_value * 0.999
      
      reference_lines <- data.frame(
        Key_point = c(avg_key_point, "Breakthrough", "Optimal begins",
                     "Saturation begins", "Full saturation", "Max efficiency"),
        Value = c(
          exact_X_avg,
          calculated_key_points$Value[calculated_key_points$Key_point == "Breakthrough"],
          calculated_key_points$Value[calculated_key_points$Key_point == "Optimal begins"],
          calculated_key_points$Value[calculated_key_points$Key_point == "Saturation begins"],
          calculated_key_points$Value[calculated_key_points$Key_point == "Full saturation"],
          calculated_key_points$Value[calculated_key_points$Key_point == "Max efficiency"]
        ),
        Color = c("#4DAF4A", "#377EB8", "#000000", "#FF69B4", "#E41A1C", "#FFD700")
      )
    }
  } else {
    # Generate key points from S-Curve
    i_max <- 1000
    index_seq <- seq(0, i_max, by = 1)
   
    # Mapping: indexing = (index_seq * Max_value) / 100 => domain in X
    data_s_curves <- data.frame(index = index_seq) %>%
      mutate(
        indexing     = (index * Max_value) / 100,
        s_curve_idx  = s_curve_indexing(indexing, alpha, beta),
        first_deriv  = first_derivative(s_curve_idx, "s-origin", alpha, beta),
        second_deriv = second_derivative(s_curve_idx, "s-origin", alpha, beta),
        third_deriv  = third_derivative(s_curve_idx, "s-origin", alpha, beta),
        ROI_max_eff  = ifelse(indexing > 0, s_curve_idx / indexing, NA)
      )
   
    # Identify 5 key points using derivatives/ROI:
    max_1st_deriv <- which.max(data_s_curves$first_deriv)
    max_2nd_deriv <- which.max(data_s_curves$second_deriv)
    min_2nd_deriv <- which.min(data_s_curves$second_deriv)
    max_ROI_eff   <- which.max(data_s_curves$ROI_max_eff)
   
    # Full saturation ~ 98%
    full_saturation_idx <- which.min(abs(data_s_curves$s_curve_idx - 0.98))
    if (length(full_saturation_idx) == 0) full_saturation_idx <- nrow(data_s_curves)
   
    # Map indexing values (X) to the real data scale
    breakthrough_val <- data_s_curves$indexing[max_2nd_deriv]
    optimal_begins_val <- data_s_curves$indexing[max_1st_deriv]
    saturation_begins_val <- data_s_curves$indexing[min_2nd_deriv]
    full_saturation_val <- data_s_curves$indexing[full_saturation_idx]
    max_efficiency_val <- data_s_curves$indexing[max_ROI_eff]
   
    # Calculate X for the average
    X_ratio <- min(max(real_avg_period / max_activity, 0), 1)
    exact_X_avg <- X_ratio * Max_value
    
    if (exact_X_avg < 0.001) exact_X_avg <- 0.001
    if (exact_X_avg > Max_value * 0.999) exact_X_avg <- Max_value * 0.999
   
    # Create dataframe with the 6 horizontal lines
    reference_lines <- data.frame(
      Key_point = c(paste0(avg_period, "_Period_Avg"), "Breakthrough", "Optimal begins",
                  "Saturation begins", "Full saturation", "Max efficiency"),
      Value = c(
        exact_X_avg, # Value for average
        breakthrough_val,
        optimal_begins_val,
        saturation_begins_val,
        full_saturation_val,
        max_efficiency_val
      ),
      Color = c("#4DAF4A", "#377EB8", "#000000", "#FF69B4", "#E41A1C", "#FFD700")
    )
  }
 
  # Min and max period for rectangles
  x_min <- min(var_activity$Period, na.rm = TRUE)
  x_max <- max(var_activity$Period, na.rm = TRUE)
 
  # Scale factor for Y axis
  scale_info <- calculate_scale_info(max_activity)
 
  # Calculate adequate vertical range for the chart
  y_max <- max(max(val_no_na, na.rm = TRUE) * 1.1,
               max(reference_lines$Value, na.rm = TRUE) * 1.05)
  
  # Round up for uniform scale
  y_max <- ceiling(y_max * 1.05)
 
  # Define zones to color
  zones <- list(
    startup = list(
      name = "Startup",
      ymin = 0,
      ymax = reference_lines$Value[reference_lines$Key_point == "Breakthrough"],
      color = "#CCCCCC", # Gray
      alpha = 0.55
    ),
    growth = list(
      name = "Growth",
      ymin = reference_lines$Value[reference_lines$Key_point == "Breakthrough"],
      ymax = reference_lines$Value[reference_lines$Key_point == "Optimal begins"],
      color = "#FFFFFF", # Transparent
      alpha = 0.01
    ),
    optimal = list(
      name = "Optimal Range",
      ymin = reference_lines$Value[reference_lines$Key_point == "Optimal begins"],
      ymax = reference_lines$Value[reference_lines$Key_point == "Saturation begins"],
      color = "#9370DB", # Purple
      alpha = 0.60
    ),
    diminishing = list(
      name = "Diminishing",
      ymin = reference_lines$Value[reference_lines$Key_point == "Saturation begins"],
      ymax = reference_lines$Value[reference_lines$Key_point == "Full saturation"],
      color = "#FFFFFF", # Transparent
      alpha = 0.01
    ),
    saturated = list(
      name = "Saturated",
      ymin = reference_lines$Value[reference_lines$Key_point == "Full saturation"],
      ymax = max(y_max * 1.1, max_activity * 1.1),
      color = "#CCCCCC", # Gray
      alpha = 0.55
    )
  )
 
  # VARIABLES FOR SCALABILITY (easily modifiable)
  red_point_size <- 6      # Larger size for red points
  red_line_width <- 2      # Greater thickness for the line connecting red points
  ref_line_thickness <- 2  # Thickness for horizontal green and yellow lines
 
  # Initialize Plotly chart
  p <- plot_ly(height = 450)
 
  # Add colored zones (without hover to not show zone names)
  for (zone_name in names(zones)) {
    zone <- zones[[zone_name]]
   
    p <- p %>% add_trace(
      x = c(x_min, x_max, x_max, x_min, x_min),
      y = c(zone$ymin, zone$ymin, zone$ymax, zone$ymax, zone$ymin),
      type = "scatter",
      mode = "none",
      fill = "toself",
      fillcolor = adjustcolor(zone$color, alpha.f = zone$alpha),
      hoverinfo = "none",  # Don't show hover for zones
      showlegend = FALSE
    )
  }
 
  # Move Saturated zone area right after zones so it doesn't interfere with points
  full_saturation_val <- reference_lines$Value[reference_lines$Key_point == "Full saturation"]
 
  p <- p %>% add_trace(
    x = c(x_min, x_max, x_max, x_min, x_min),
    y = c(full_saturation_val, full_saturation_val, y_max*1.1, y_max*1.1, full_saturation_val),
    type = "scatter",
    mode = "none",
    fill = "toself",
    fillcolor = adjustcolor("#CCCCCC", alpha.f = 0.55),  # Same color as startup
    hoverinfo = "none",  # Don't show hover for zones
    showlegend = FALSE
  )
 
  # Add time series line (black connected line, with greater thickness)
  p <- p %>% add_trace(
    data = var_activity,
    x = ~Period,
    y = ~value,
    type = "scatter",
    mode = "lines",
    line = list(color = "#1A1A1A", width = red_line_width),
    hoverinfo = "none",
    showlegend = FALSE
  )
 
  # Add horizontal reference lines with thickness adjustment for green and yellow
  for (i in 1:nrow(reference_lines)) {
    line <- reference_lines[i, ]
   
    # Change specific colors to dark gray
    lineColor <- line$Color
    if (lineColor %in% c("#377EB8", "#FF69B4", "#E41A1C")) {
      lineColor <- "#444444"  # Dark gray for lines that were blue, pink or red
    }
   
    # Determine if line should be dash or solid and adjust thickness for green and yellow
    if (line$Key_point %in% c(paste0(avg_period, "_Period_Avg"), "Max efficiency")) {
      lineDash <- "dash"
      line_width <- ref_line_thickness
    } else {
      lineDash <- "solid"
      line_width <- 1.0
    }
   
    # Improve hover text with HTML format for better visualization
    hover_text <- paste0("<b>", line$Key_point, "</b><br>",
                         "Value: ", format(round(line$Value, 2), big.mark = ","))
   
    p <- p %>% add_trace(
      x = c(x_min, x_max),
      y = c(line$Value, line$Value),
      type = "scatter",
      mode = "lines",
      line = list(color = lineColor, width = line_width, dash = lineDash),
      hoverinfo = "text",
      text = hover_text,
      hoveron = "points+lines",  # Hover on the entire line, not just extremes
      showlegend = FALSE
    )
  }
 
  # Finally, add red points (only for non-zero values)
  # Filter out very low values for the markers
  var_activity_for_markers <- var_activity %>%
    filter(value > max_activity * 0.01)  # Only show points for values > 1% of max
  
  p <- p %>% add_trace(
    data = var_activity_for_markers,
    x = ~Period,
    y = ~value,
    type = "scatter",
    mode = "markers",
    marker = list(color = "#E41A1C", size = red_point_size),
    hoverinfo = "text",
    text = ~paste(
      "<b>Date:</b>", format(Period, "%Y-%m-%d"),
      "<br><b>Value:</b>", format(round(value, 2), big.mark = ",")
    ),
    showlegend = FALSE
  )
  
  # Calculate exact ticks for Y axis
  # Make sure it matches the X axis of the S curve
  tick_count <- 6  # Number of ticks
  tick_values <- round(seq(0, y_max, length.out = tick_count))
  
  # Custom function to format axis labels without duplicates
  format_axis_label <- function(value) {
    if (value >= 1000) {
      suffix <- "k"
      formatted_value <- value / 1000
      return(paste0(formatted_value, suffix))
    } else {
      return(as.character(value))
    }
  }
  
  # Generate unique axis labels
  axis_labels <- sapply(tick_values, format_axis_label)
 
  # Configure chart layout with specific ticks
  p <- p %>% layout(
    xaxis = list(
      title = list(
        text = "Period",
        font = list(size = 12, family = "Arial, sans-serif", color = "#000000"),
        standoff = 15  # Increase distance between title and axis
      ),
      type = "date",
      range = c(x_min, x_max),
      tickformat = "%Y-%m",
      dtick = "M3",
      tickangle = -45,
      gridcolor = "#EEEEEE",
      automargin = TRUE  # Allow auto margin to avoid cropping
    ),
    yaxis = list(
      title = list(
        text = "Activity",
        font = list(size = 12, family = "Arial, sans-serif", color = "#000000"),
        standoff = 15  # Increase distance between title and axis
      ),
      range = c(0, y_max),
      tickmode = "array",  # Use specific ticks
      tickvals = tick_values,  # Tick values
      ticktext = axis_labels,  # Custom formatted labels
      gridcolor = "#EEEEEE",
      automargin = TRUE  # Allow auto margin to avoid cropping
    ),
    hovermode = "closest",
    hoverdistance = 50,  # Increase hover detection distance
    hoverlabel = list(
      bgcolor = "white",
      font = list(size = 12, color = "black", family = "Arial, sans-serif"),
      bordercolor = "darkgray",
      namelength = -1  # No limit for name length
    ),
    showlegend = FALSE,
    margin = list(l = 70, r = 50, b = 80, t = 20, pad = 5),  # Increase margins
    paper_bgcolor = "#FFFFFF",
    plot_bgcolor = "#FFFFFF"
  ) %>%
  config(
    displayModeBar = FALSE,
    responsive = TRUE
  )
 
  # Save configuration values to coordinate with S-Curve
  attr(p, "key_points") <- reference_lines
  attr(p, "y_max") <- y_max
  attr(p, "tick_values") <- tick_values
  attr(p, "axis_labels") <- axis_labels
  return(p)
}


# -------------------------------------------------------------------------
# create_s_curve_chart():
#   - Plots the S curve in the range 0..1000 (i_max).
#   - Includes 6 key points: Breakthrough, Optimal begins, Saturation begins,
#     Full saturation, Max efficiency and 52w_Avg.
# -------------------------------------------------------------------------
create_s_curve_chart <- function(data_chart, alpha, beta, max_val_pct, decay = 1, lag = 0, var_name = "Variable", 
                                avg_period = 52, avg_data = NULL, flighting_chart = NULL) {
 
  if (!is.data.frame(data_chart) || !all(c("Period", "value") %in% names(data_chart))) {
    return(plot_ly() %>% layout(title = "Invalid data for S-Curve Chart."))
  }
  
  # Filter out zeros for calculations
  data_chart_no_zeros <- data_chart %>%
    filter(value > 0)
 
  val_no_na <- data_chart_no_zeros$value[!is.na(data_chart_no_zeros$value)]
  if (length(val_no_na) < 1) {
    return(plot_ly() %>% layout(title = "No valid data for S-Curve."))
  }
 
  # Real maximum of the activity
  max_activity <- max(val_no_na, na.rm = TRUE)
  if (!is.finite(max_activity) || max_activity == 0) max_activity <- 1
 
  # Determine "Max_value" based on max_val_pct
  Max_value <- max_activity * (max_val_pct / 100)
  
  # If we have a flighting_chart, get its configuration values
  y_max <- NULL
  tick_values <- NULL
  axis_labels <- NULL
  if (!is.null(flighting_chart)) {
    y_max <- attr(flighting_chart, "y_max")
    tick_values <- attr(flighting_chart, "tick_values")
    axis_labels <- attr(flighting_chart, "axis_labels")
  }
  
  # If we don't have values from flighting_chart, calculate our own values
  if (is.null(y_max)) {
    y_max <- ceiling(max_activity * 1.1)
  }
  
  if (is.null(tick_values)) {
    tick_count <- 6  # Number of ticks
    tick_values <- round(seq(0, y_max, length.out = tick_count))
  }
  
  if (is.null(axis_labels)) {
    axis_labels <- as.character(tick_values)
  }
 
  # Generate points 0..i_max for 'index'
  i_max <- 1000
  index_seq <- seq(0, i_max, by = 1)
 
  # Mapping: indexing = (index_seq * Max_value) / 100 => domain in X
  data_s_curves <- data.frame(index = index_seq) %>%
    mutate(
      indexing     = (index * Max_value) / 100,
      s_curve_idx  = s_curve_indexing(indexing, alpha, beta),
      first_deriv  = first_derivative(s_curve_idx, "s-origin", alpha, beta),
      second_deriv = second_derivative(s_curve_idx, "s-origin", alpha, beta),
      third_deriv  = third_derivative(s_curve_idx, "s-origin", alpha, beta),
      ROI_max_eff  = ifelse(indexing > 0, s_curve_idx / indexing, NA)
    )
 
  # Identify key points using derivatives/ROI:
  max_1st_deriv <- which.max(data_s_curves$first_deriv)
  max_2nd_deriv <- which.max(data_s_curves$second_deriv)
  min_2nd_deriv <- which.min(data_s_curves$second_deriv)
  max_ROI_eff <- which.max(data_s_curves$ROI_max_eff)
 
  # Full saturation ~ 98%
  full_saturation_idx <- which.min(abs(data_s_curves$s_curve_idx - 0.98))
  if (length(full_saturation_idx) == 0) full_saturation_idx <- nrow(data_s_curves)
 
  # Create data.frame with key points
  key_points_df <- data.frame(
    Key_point = c(
      "Breakthrough", "Optimal begins", "Saturation begins",
      "Full saturation", "Max efficiency"
    ),
    Index_X = c(
      data_s_curves$indexing[max_2nd_deriv],
      data_s_curves$indexing[max_1st_deriv],
      data_s_curves$indexing[min_2nd_deriv],
      data_s_curves$indexing[full_saturation_idx],
      data_s_curves$indexing[max_ROI_eff]
    ),
    S_Curve_Value = c(
      data_s_curves$s_curve_idx[max_2nd_deriv],
      data_s_curves$s_curve_idx[max_1st_deriv],
      data_s_curves$s_curve_idx[min_2nd_deriv],
      data_s_curves$s_curve_idx[full_saturation_idx],
      data_s_curves$s_curve_idx[max_ROI_eff]
    ),
    Value = c(
      data_s_curves$indexing[max_2nd_deriv],
      data_s_curves$indexing[max_1st_deriv],
      data_s_curves$indexing[min_2nd_deriv],
      data_s_curves$indexing[full_saturation_idx],
      data_s_curves$indexing[max_ROI_eff]
    ),
    Color = c("#000000", "#000000", "#000000", "#000000", "#FFD700")
  )
 
  # Calculate average using filtered data if available
  if (!is.null(avg_data) && nrow(avg_data) > 0) {
    # Filter out zeros
    avg_data_no_zeros <- avg_data %>%
      filter(value > 0)
    
    if (nrow(avg_data_no_zeros) > 0) {
      real_avg_period <- mean(avg_data_no_zeros$value, na.rm = TRUE)
      if (is.na(real_avg_period)) real_avg_period <- 0
      avg_period <- nrow(avg_data_no_zeros)  # Update avg_period to number of rows in filtered avg_data
    } else {
      # If no non-zero data in range, use default calculation
      real_avg_period <- mean(data_chart_no_zeros$value, na.rm = TRUE)
      if (is.na(real_avg_period)) real_avg_period <- 0
    }
  } else {
    # If no avg_data provided, calculate from non-zero values
    real_avg_period <- mean(data_chart_no_zeros$value, na.rm = TRUE)
    if (is.na(real_avg_period)) real_avg_period <- 0
  }
 
  X_ratio <- min(max(real_avg_period / max_activity, 0), 1)
  X_avg <- X_ratio * Max_value
 
  if (X_avg < 0.001) X_avg <- 0.001
  if (X_avg > Max_value * 0.999) X_avg <- Max_value * 0.999
 
  Y_avg <- find_y_for_x_on_curve(X_avg, alpha, beta)
 
  closest_point_idx <- which.min(abs(data_s_curves$indexing - X_avg))
 
  if (length(closest_point_idx) > 0 && closest_point_idx <= nrow(data_s_curves)) {
    exact_X_avg <- data_s_curves$indexing[closest_point_idx]
    exact_Y_avg <- data_s_curves$s_curve_idx[closest_point_idx]
  } else {
    exact_X_avg <- X_avg
    exact_Y_avg <- Y_avg
  }
 
  # Add average point
  key_points_df <- rbind(
    key_points_df,
    data.frame(
      Key_point     = paste0(avg_period, "_Period_Avg"),
      Index_X       = exact_X_avg,
      S_Curve_Value = exact_Y_avg,
      Value         = exact_X_avg,
      Color         = "#4DAF4A" # Green
    )
  )
 
  # Scale factor
  scale_info <- calculate_scale_info(max_activity)
 
  # Adjust X limits to coordinate with flighting chart
  x_max_value <- y_max  # Use same max value as Y axis of flighting chart
 
  # Initialize Plotly chart
  p <- plot_ly()
 
  # Define zone coordinates (with hoverinfo = "none" to not show names)
  zones <- list(
    startup = list(
      name = "Startup",
      xmin = 0,
      xmax = key_points_df$Index_X[key_points_df$Key_point == "Breakthrough"],
      color = "#FFFFFF",
      alpha = 0.55
    ),
    growth = list(
      name = "Growth",
      xmin = key_points_df$Index_X[key_points_df$Key_point == "Breakthrough"],
      xmax = key_points_df$Index_X[key_points_df$Key_point == "Optimal begins"],
      color = "#FFFFFF",
      alpha = 0.01
    ),
    optimal = list(
      name = "Optimal Range",
      xmin = key_points_df$Index_X[key_points_df$Key_point == "Optimal begins"],
      xmax = key_points_df$Index_X[key_points_df$Key_point == "Saturation begins"],
      color = "#9370DB",
      alpha = 0.6
    ),
    diminishing = list(
      name = "Diminishing",
      xmin = key_points_df$Index_X[key_points_df$Key_point == "Saturation begins"],
      xmax = key_points_df$Index_X[key_points_df$Key_point == "Full saturation"],
      color = "#FFFFFF",
      alpha = 0.01
    ),
    saturated = list(
      name = "Saturated",
      xmin = key_points_df$Index_X[key_points_df$Key_point == "Full saturation"],
      xmax = x_max_value,
      color = "#FFFFFF",
      alpha = 0.55
    )
  )
 
  # Add zones
  for (zone_name in names(zones)) {
    zone <- zones[[zone_name]]
   
    p <- p %>% add_trace(
      x = c(zone$xmin, zone$xmax, zone$xmax, zone$xmin, zone$xmin),
      y = c(0, 0, 1, 1, 0),
      type = "scatter",
      mode = "none",
      fill = "toself",
      fillcolor = adjustcolor(zone$color, alpha.f = zone$alpha),
      hoverinfo = "none",  # Don't show hover for zones
      showlegend = FALSE
    )
  }
 
  # Add S curve (slightly thicker)
  p <- p %>% add_trace(
    data = data_s_curves,
    x = ~indexing,
    y = ~s_curve_idx,
    type = "scatter",
    mode = "lines",
    line = list(color = "#1A1A1A", width = 1.2),
    hoverinfo = "none",
    showlegend = FALSE
  )
 
  # VARIABLE FOR S CURVE POINT SCALABILITY
  s_point_size <- 7
 
  # Add key points (larger size for points, using s_point_size)
  for (i in 1:nrow(key_points_df)) {
    point <- key_points_df[i, ]
   
    # Change specific colors to dark gray (for points that were red, pink or blue)
    pointColor <- point$Color
    if (pointColor %in% c("#377EB8", "#FF69B4", "#E41A1C")) {
      pointColor <- "#444444"  # Dark gray
    }
   
    p <- p %>% add_trace(
      x = point$Index_X,
      y = point$S_Curve_Value,
      type = "scatter",
      mode = "markers",
      marker = list(
        color = pointColor,
        size = s_point_size
      ),
      hoverinfo = "text",
      text = paste0(
        "<b>", point$Key_point, "</b><br>",
        "X: ", format(round(point$Index_X, 2), big.mark = ","), "<br>",
        "Y: ", format(round(point$S_Curve_Value * 100, 1), big.mark = ","), "%"
      ),
      showlegend = FALSE
    )
  }
 
  # Configure chart layout with identical ticks to flighting chart
  p <- p %>% layout(
    xaxis = list(
      title = list(
        text = "Activity",
        font = list(size = 12, family = "Arial, sans-serif", color = "#000000"),
        standoff = 15
      ),
      range = c(0, x_max_value),
      tickmode = "array",
      tickvals = tick_values,  # Use same tick values as Y axis of flighting chart
      ticktext = axis_labels,  # Use same custom labels
      gridcolor = "#EEEEEE",
      automargin = TRUE
    ),
    yaxis = list(
      title = list(
        text = "Index Value",
        font = list(size = 12, family = "Arial, sans-serif", color = "#000000"),
        standoff = 15
      ),
      tickformat = ".0%",
      range = c(0, 1),
      gridcolor = "#EEEEEE",
      automargin = TRUE
    ),
    hovermode = "closest",
    hoverdistance = 50,
    hoverlabel = list(
      bgcolor = "white",
      font = list(size = 12, color = "black", family = "Arial, sans-serif"),
      bordercolor = "darkgray",
      namelength = -1
    ),
    showlegend = FALSE,
    margin = list(l = 70, r = 50, b = 70, t = 20, pad = 5),
    paper_bgcolor = "#FFFFFF",
    plot_bgcolor = "#FFFFFF"
  ) %>%
  config(
    displayModeBar = FALSE,
    responsive = TRUE
  )
 
  # Save key points to use in flighting chart
  attr(p, "key_points") <- key_points_df
  return(p)
}# S_Curve_Helpers.R


# Módulo de Funciones Helper (Transformaciones, Derivadas, Escalado, Outliers)

s_curve_transform <- function(x, shape = "s-origin", alpha = 0.85, beta = 1, maxValuePct = 100) {
  if (!is.numeric(x) || length(x) == 0) return(numeric(0))
  if (all(is.na(x))) return(x)
  max_val <- max(x, na.rm = TRUE)
  if (!is.finite(max_val) || max_val == 0) return(x)
  
  i_max <- length(x)
  result <- switch(
    tolower(shape),
    "s-shaped" = {
      (beta / 1e10)^(alpha^seq_len(i_max))
    },
    "s-origin" = {
      (beta / 1e9)^(alpha^seq_len(i_max)) - (beta / 1e9)
    },
    "indexp" = {
      1 - exp(-alpha * seq_len(i_max) / 10)
    },
    x
  )
  return(result)
}

# -------------------------------------------------------------------------
# s_curve_indexing:
#   Devuelve el valor S-Curve en Y dado un X (indexing).
#   indexing => 0..(cierto máximo)
# -------------------------------------------------------------------------
s_curve_indexing <- function(serie, alpha, beta, index_step = 1) {
  if (length(serie) == 0) return(numeric(0))
  
  # Si es un solo número, calculamos su valor en la curva directamente
  if (length(serie) == 1) {
    beta_calc <- beta / 1e9
    return(beta_calc^(alpha^serie) - beta_calc)
  }
  
  # Para vectores o dataframes
  i_max <- if (is.data.frame(serie)) nrow(serie) else length(serie)
  if (i_max < 1) return(numeric(0))
  
  # Para cada posición en 'index', calculamos la curva s-origin
  index <- seq(0, (i_max - 1), by = index_step)
  beta_calc <- beta / 1e9
  beta_calc^(alpha^index) - beta_calc
}

first_derivative <- function(x, shape = "s-origin", alpha, beta, index_step = 1) {
  i_max <- length(x)
  if (i_max < 1) return(numeric(0))
  index <- seq(0, (i_max - 1), by = index_step)
  switch(
    tolower(shape),
    "s-origin" = (beta / 1e9)^(alpha^index) * alpha^index * log(beta / 1e9) * log(alpha),
    "s-shaped" = (beta / 1e10)^(alpha^index) * alpha^index * log(beta / 1e10) * log(alpha),
    "indexp"   = (alpha * exp(-(alpha * index) / 10)) / 10,
    rep(NA, i_max)
  )
}

second_derivative <- function(x, shape = "s-origin", alpha, beta, index_step = 1) {
  i_max <- length(x)
  if (i_max < 1) return(numeric(0))
  index <- seq(0, (i_max - 1), by = index_step)
  switch(
    tolower(shape),
    "s-origin" = {
      log(beta / 1e9) * log(alpha) * (
        ((beta / 1e9)^(alpha^index) * alpha^(2 * index) * log(beta / 1e9) * log(alpha)) +
        ((beta / 1e9)^(alpha^index) * alpha^index * log(alpha))
      )
    },
    "s-shaped" = {
      log(beta / 1e10) * log(alpha) * (
        ((beta / 1e10)^(alpha^index) * alpha^(2 * index) * log(beta / 1e10) * log(alpha)) +
        ((beta / 1e10)^(alpha^index) * alpha^index * log(alpha))
      )
    },
    "indexp"   = (-(alpha^2) * exp(-(alpha * index) / 10)) / 100,
    rep(NA, i_max)
  )
}

third_derivative <- function(x, shape = "s-origin", alpha, beta, index_step = 1) {
  i_max <- length(x)
  if (i_max < 1) return(numeric(0))
  index <- seq(0, (i_max - 1), by = index_step)
  switch(
    tolower(shape),
    "s-origin" = {
      log(beta / 1e9) * log(alpha) * (
        ((beta / 1e9)^(alpha^index) * alpha^(3 * index) * (log(beta / 1e9))^2 * (log(alpha))^2) +
        3 * ((beta / 1e9)^(alpha^index) * alpha^(2 * index) * log(beta / 1e9) * (log(alpha))^2) +
        ((beta / 1e9)^(alpha^index) * alpha^index * (log(alpha))^2)
      )
    },
    "s-shaped" = {
      log(beta / 1e10) * log(alpha) * (
        ((beta / 1e10)^(alpha^index) * alpha^(3 * index) * (log(beta / 1e10))^2 * (log(alpha))^2) +
        3 * ((beta / 1e10)^(alpha^index) * alpha^(2 * index) * log(beta / 1e10) * (log(alpha))^2) +
        ((beta / 1e10)^(alpha^index) * alpha^index * (log(alpha))^2)
      )
    },
    "indexp"   = ((alpha^3) * exp(-(alpha * index) / 10)) / 1000,
    rep(NA, i_max)
  )
}

# -------------------------------------------------------------------------
# get_point_on_curve:
#   Encuentra el punto X exacto en la curva S que da el valor Y más cercano
# -------------------------------------------------------------------------
# -------------------------------------------------------------------------
# find_x_for_y_on_curve:
#   Encuentra el valor X exacto en la curva que corresponde a un valor Y dado
# -------------------------------------------------------------------------
find_x_for_y_on_curve <- function(target_y, alpha, beta, max_value, precision = 0.0001) {
  # Validación mejorada
  if (!is.finite(target_y) || target_y <= 0) return(0)
  if (target_y >= 1) return(max_value)
  
  # Función para calcular Y dado X
  calc_y <- function(x) {
    beta_calc <- beta / 1e9
    return(beta_calc^(alpha^x) - beta_calc)
  }
  
  # Búsqueda binaria para encontrar el X que produce el Y objetivo
  lower_x <- 0
  upper_x <- max_value * 3  # Rango amplio para asegurar encontrar el punto
  
  iter <- 0
  max_iter <- 100  # Límite de iteraciones para prevenir bucles infinitos
  
  while ((upper_x - lower_x) > precision && iter < max_iter) {
    mid_x <- (lower_x + upper_x) / 2
    mid_y <- calc_y(mid_x)
    
    if (abs(mid_y - target_y) < precision) {
      return(mid_x)  # Encontramos un punto suficientemente cercano
    }
    
    if (mid_y < target_y) {
      lower_x <- mid_x
    } else {
      upper_x <- mid_x
    }
    
    iter <- iter + 1
  }
  
  return((lower_x + upper_x) / 2)
}

# -------------------------------------------------------------------------
# find_y_for_x_on_curve:
#   Calcula el valor Y exacto en la curva para un valor X dado
#   CORREGIDO: Manejo mejorado para garantizar punto exacto en la curva
# -------------------------------------------------------------------------
find_y_for_x_on_curve <- function(x_value, alpha, beta) {
  # Validación más estricta para evitar problemas con el punto 52w_Avg
  if (is.na(x_value) || !is.finite(x_value)) {
    x_value <- 0
    return(0)
  }
  
  if (x_value < 0) {
    x_value <- 0
  }
  
  # Para x_value muy grande, aseguramos que no cause problemas numéricos
  if (x_value > 1000) {
    return(0.98) # Aproximación a saturación completa
  }
  
  # Fórmula S-curve original
  beta_calc <- beta / 1e9
  y_val <- beta_calc^(alpha^x_value) - beta_calc
  
  # Evitar valores no válidos (NaN, Inf, etc.)
  if (!is.finite(y_val)) {
    if (x_value < 0.1) return(0)
    if (x_value > 100) return(0.98)
    return(0.5) # Valor intermedio como fallback
  }
  
  return(y_val)
}

# -------------------------------------------------------------------------
# apply_transformation:
#   Aplica distintas transformaciones a un vector, incluyendo "S Origin",
#   "S Shaped", etc., con decay y lag.
# -------------------------------------------------------------------------
apply_transformation <- function(data, type = "Linear", alpha = 1, beta = 1, maxval = 100, decay = 1, lag = 0) {
  if (is.null(data) || length(data) == 0) return(numeric(0))
  if (all(is.na(data))) return(data)
  data[data < 0] <- 0
  
  if (lag > 0) {
    if (lag >= length(data)) {
      data <- rep(NA, length(data))
    } else {
      data <- c(rep(NA, lag), head(data, -lag))
    }
  }
  data <- data * decay
  
  out <- switch(
    type,
    "Linear"     = data,
    "S Origin"   = s_curve_transform(data, "s-origin", alpha, beta, maxval),
    "S Shaped"   = s_curve_transform(data, "s-shaped", alpha, beta, maxval),
    "Index Exp"  = 1 - exp(- (alpha / 10) * (data / max(data, na.rm = TRUE))),
    "Log"        = log1p(data),
    "Exp"        = 1 - exp(-(data / alpha)),
    "Power"      = data^alpha,
    "Moving Avg" = {
      if (length(data) < 3) rep(NA, length(data)) 
      else zoo::rollmean(data, k = 3, fill = NA, align = "right")
    },
    data
  )
  return(out)
}

# -------------------------------------------------------------------------
# calculate_scale_info:
#   Determina factor de escala y sufijo (K, M, B, T) para ejes de gráficas.
# -------------------------------------------------------------------------
calculate_scale_info <- function(mean_value) {
  if (mean_value < 1000) {
    list(number = 1, suffix = "")
  } else if (mean_value < 1e6) {
    list(number = 1e3, suffix = "K")
  } else if (mean_value < 1e9) {
    list(number = 1e6, suffix = "M")
  } else if (mean_value < 1e12) {
    list(number = 1e9, suffix = "B")
  } else {
    list(number = 1e12, suffix = "T")
  }
}

# -------------------------------------------------------------------------
# handle_outliers:
#   Reemplaza valores atípicos por NA usando método IQR
# -------------------------------------------------------------------------
handle_outliers <- function(data, method = "iqr", threshold = 1.5) {
  if (length(data) < 4) return(data)
  
  q1 <- quantile(data, 0.25, na.rm = TRUE)
  q3 <- quantile(data, 0.75, na.rm = TRUE)
  iqr <- q3 - q1
  
  lower_bound <- q1 - threshold * iqr
  upper_bound <- q3 + threshold * iqr
  
  data[data < lower_bound | data > upper_bound] <- NA
  return(data)
}# Data_Loader.R

# =============================================================================
# Function to load a dataset from a CSV or RData file,
# with robust error handling and automatic encoding detection.
# =============================================================================

load_data <- function(file) {
  # Loads data from a CSV or RData file
  #
  # Args:
  #   file: File object uploaded via Shiny's fileInput
  #
  # Returns:
  #   A dataframe with the loaded data, or NULL in case of an error
  
  req(file)
  ext <- tools::file_ext(file$name)
  tryCatch({
    if (ext == "csv") {
      # Encoding detection
      encoding <- readr::guess_encoding(file$datapath)
      if (nrow(encoding) > 0) {
        data <- read.csv(file$datapath, stringsAsFactors = FALSE, encoding = encoding$encoding[1])
      } else {
        # Fallback encodings
        data <- tryCatch({
          read.csv(file$datapath, stringsAsFactors = FALSE, encoding = "UTF-8")
        }, error = function(e) {
          read.csv(file$datapath, stringsAsFactors = FALSE, encoding = "Latin1")
        })
      }
    } else if (ext == "RData") {
      env <- new.env()
      load(file$datapath, envir = env)
      objs <- ls(env)
      data_objs <- objs[sapply(objs, function(x) is.data.frame(get(x, envir = env)))]
      if (length(data_objs) == 0) {
        stop("The .RData file does not contain any data.frame.")
      }
      data <- get(data_objs[1], envir = env)
      if (!is.data.frame(data)) {
        stop("The selected object is not a data.frame.")
      }
    } else {
      stop("Unsupported file format. Please upload a .csv or .RData file.")
    }
    notifyUser("File loaded successfully.", "message")
    return(data)
  }, error = function(e) {
    notifyUser(paste("Error loading file:", e$message), "error")
    return(NULL)
  })
}
# Data_Summary.R

# =============================================================================
# Renders the data summary table by applying the required calculations 
# and formatting. For each media variable, the corresponding cost variable 
# is found using keywords: Impressions, Clicks, Circulation, etc.
# =============================================================================

data_summary_module_server <- function(input, output, session, rv) {
  # Server module for the data summary table
  #
  # Args:
  #   input: Shiny input object
  #   output: Shiny output object
  #   session: Shiny session object
  #   rv: Shared reactive values
  
  # Reactive function that generates the consolidated table
  consolidated_table <- reactive({
    # Requires filtered data and selected media variables
    req(rv$filtered_data)
    req(input$media_vars)
    
    if (nrow(rv$filtered_data) == 0) {
      return(data.frame(Message = "No data available."))
    }
    
    results_list <- list()
    df <- rv$filtered_data
    
    # Try to detect date column
    date_col <- rv$date_col
    total_weeks <- if (!is.null(date_col) && date_col %in% names(df)) {
      n_distinct(df[[date_col]])
    } else {
      NA
    }
    
    # For each media variable
    for (mvar in input$media_vars) {
      # Identify keyword
      keyword <- NULL
      for (kw in c("Impressions", "Clicks", "Circulation")) {
        if (grepl(kw, mvar, ignore.case = TRUE)) {
          keyword <- kw
          break
        }
      }
      if (is.null(keyword)) next
      
      # Possible cost variable
      possible_spend_candidates <- c(
        gsub(keyword, "Spend", mvar, ignore.case = TRUE),
        gsub(keyword, "Cost", mvar, ignore.case = TRUE)
      )
      spend_var <- NA
      for (candidate in possible_spend_candidates) {
        found <- names(df)[tolower(names(df)) == tolower(candidate)]
        if (length(found) > 0) {
          spend_var <- found[1]
          break
        }
      }
      
      # Media aggregation
      media_agg <- df %>%
        group_by(Geography) %>%
        summarise(
          Activity = sum(.data[[mvar]], na.rm = TRUE),
          Weeks_Activity = if (!is.na(total_weeks)) {
            n_distinct(.data[[date_col]][.data[[mvar]] > 0])
          } else { NA }
        ) %>%
        ungroup()
      
      # Cost aggregation if found
      if (!is.na(spend_var)) {
        spend_agg <- df %>%
          group_by(Geography) %>%
          summarise(
            Spend = sum(.data[[spend_var]], na.rm = TRUE),
            Weeks_Spend = if (!is.na(total_weeks)) {
              n_distinct(.data[[date_col]][.data[[spend_var]] > 0])
            } else { NA }
          ) %>%
          ungroup()
      } else {
        spend_agg <- df %>%
          distinct(Geography) %>%
          mutate(Spend = NA_real_, Weeks_Spend = NA_integer_)
      }
      
      # Merge
      merged_df <- left_join(media_agg, spend_agg, by = "Geography")
      

      # Summary
      total_activity <- sum(merged_df$Activity, na.rm = TRUE)
      total_spend    <- sum(merged_df$Spend, na.rm = TRUE)
      
      merged_df <- merged_df %>%
        mutate(
          `Activity %` = ifelse(total_activity > 0, round(Activity / total_activity * 100, 2), 0),
          `Spend %`    = ifelse(total_spend > 0,    round(Spend / total_spend * 100, 2), 0),
          `Activity Distribution %` = if (!is.na(total_weeks) && total_weeks > 0) {
            round(Weeks_Activity / total_weeks * 100, 2)
          } else { NA },
          `Spend Distribution %` = if (!is.na(total_weeks) && total_weeks > 0) {
            round(Weeks_Spend / total_weeks * 100, 2)
          } else { NA }
        )
      
      # CPC/CPM based on keyword
      merged_df <- merged_df %>%
        mutate(
          `CPC/CPM` = case_when(
            keyword %in% c("Impressions", "Circulation") & Activity > 0 ~ round(Spend / Activity * 1000, 2),
            keyword == "Clicks" & Activity > 0 ~ round(Spend / Activity, 2),
            TRUE ~ NA_real_
          )
        )
      
      # RAG or No-RAG
      rag_type <- if (n_distinct(merged_df$Activity) == 1) "RAG" else "No-RAG"
      
      merged_df <- merged_df %>%
        mutate(
          `Media Variable` = mvar,
          `Spend Variable` = ifelse(is.na(spend_var), "", spend_var),
          Type = rag_type
        ) %>%
        select(
          `Media Variable`,
          `Spend Variable`,
          Type,
          Geography,
          Activity,
          Spend,
          `Activity %`,
          `Spend %`,
          Weeks_Activity,
          `Activity Distribution %`,
          Weeks_Spend,
          `Spend Distribution %`,
          `CPC/CPM`
        )
      
      # If rag_type == "RAG", keep only the first row
      if (rag_type == "RAG") {
        merged_df <- merged_df %>% slice(1)
      }
      
      results_list[[mvar]] <- merged_df
    }
    
    if (length(results_list) == 0) {
      return(data.frame(Message = "No media variables found with the required keywords."))
    }
    
    final_table <- bind_rows(results_list)
    
    # Additional step: recalculate global totals within the table
    final_table <- final_table %>%
      summarise(
        total_activity = sum(Activity, na.rm = TRUE),
        total_spend    = sum(Spend, na.rm = TRUE),
        .groups        = 'drop'
      ) %>%
      right_join(final_table, by = character()) %>%
      group_by(`Media Variable`) %>%
      mutate(
        `Activity %` = ifelse(
          total_activity > 0,
          round(Activity / total_activity * 100, 2),
          0
        ),
        `Spend %` = ifelse(
          total_spend > 0,
          round(Spend / total_spend * 100, 2),
          0
        )
      ) %>%
      ungroup() %>%
      select(-total_activity, -total_spend) %>%
      arrange(`Media Variable`, Geography)
    
    return(final_table)
  })
  
  # Render the table
  output$consolidated_table <- renderDT({
    table_data <- consolidated_table()
    
    if ("Message" %in% names(table_data)) {
      return(datatable(table_data, options = list(dom = 't')))
    }
    
    # Format numeric columns
    table_data <- table_data %>%
      mutate(
        across(where(is.numeric),
               ~ format(
                 .,
                 big.mark       = ",",
                 decimal.mark   = ".",
                 nsmall         = 2,
                 scientific     = FALSE
               ))
      )
    
    datatable(
      table_data,
      filter = "top",
      rownames = FALSE,
      options = list(
        pageLength = 10,
        autoWidth = TRUE,
        scrollX = TRUE,
        dom = 'Bfrtip',
        buttons = c('copy', 'csv', 'excel')
      ),
      extensions = 'Buttons'
    )
  })
  
  outputOptions(output, "consolidated_table", suspendWhenHidden = FALSE)
  
  output$download_consolidated <- downloadHandler(
    filename = function() {
      paste("Summary_Table_", Sys.Date(), ".csv", sep = "")
    },
    content = function(file) {
      write.csv(consolidated_table(), file, row.names = FALSE)
    }
  )
  
  return(consolidated_table)
}
# Date_Filter.R

# =============================================================================
# Common function to filter data by date range from the "Information" tab.
# =============================================================================

filter_data_by_date <- function(input, rv) {
  # Filters data by date range and updates reactive values
  #
  # Args:
  #   input: Shiny input object
  #   rv: Shared reactive values

  observe({
    req(rv$data, input$date_range_filter)
    df <- rv$data

    # Try to detect date column from rv$date_col
    date_col <- rv$date_col
    if (!is.null(date_col) && date_col %in% names(df)) {
      # Ensure column is Date
      df[[date_col]] <- as.Date(df[[date_col]])
      # Filter
      df <- filter_by_date(df, input$date_range_filter[1], input$date_range_filter[2])
      rv$filtered_data <- df  # Update globally filtered data
    }
    notifyUser("Data filtered by date range.", "message", duration = 2)
  })
}

# Dimensions.R

# =============================================================================
# Renders the outputs to detect temporal and cross-sectional
# dimensions of the dataset.
# =============================================================================

dimensions_ui_module_server <- function(input, output, session, rv) {
  # Server module to display information about dataset dimensions
  #
  # Args:
  #   input: Shiny input object
  #   output: Shiny output object
  #   session: Shiny session object
  #   rv: Shared reactive values
  
  output$temporal_dimension_ui <- renderUI({
    req(rv$date_col)
    div(rv$date_col)
  })
  
  output$cross_sectional_dimension_ui <- renderUI({
    req(rv$data)
    keywords <- c("Geography", "Geografia", "Product", "Campaign", "Outlet", "Creative")
    available_columns <- names(rv$data)[names(rv$data) %in% keywords]
    if (length(available_columns) > 0) {
      div(paste(available_columns, collapse = ", "))
    } else {
      div("No cross-sectional dimensions were detected in the dataset.")
    }
  })
}
# File_Info.R

# =============================================================================
# Displays basic information about the uploaded file.
# =============================================================================

file_info_module_server <- function(input, output, session, rv) {
  # Server module to display basic file information
  #
  # Args:
  #   input: Shiny input object
  #   output: Shiny output object
  #   session: Shiny session object
  #   rv: Shared reactive values
  
  output$file_details <- renderPrint({
    req(rv$data)
    df <- rv$data
    cat("Number of Rows:", nrow(df), "\n")
    cat("Number of Columns:", ncol(df), "\n")
  })
}
# =============================================================================
# Boxplot for Multivariate tab.
# =============================================================================

# Function that generates a boxplot for 'sum_vars' ignoring NA and zeros,
# in horizontal orientation.
render_summed_boxplot <- function(df) {
  # Verify that the dataframe is not NULL
  req(df)
  
  # Check that the 'sum_vars' column exists
  if (!"sum_vars" %in% names(df)) {
    return(plot_ly() %>% layout(title = "Column 'sum_vars' does not exist."))
  }
  
  # Filter NA values and zeros
  non_zero_sum_vars <- df$sum_vars
  non_zero_sum_vars <- non_zero_sum_vars[!is.na(non_zero_sum_vars) & non_zero_sum_vars != 0]
  
  # Validate that valid data exists
  if (length(non_zero_sum_vars) == 0) {
    return(plot_ly() %>% layout(title = "No non-zero data in 'sum_vars'."))
  }
  
  # Create horizontal boxplot with Plotly (clean y-axis)
  plot_ly(
    y = "",  # Empty category to suppress Y-axis label like "orange"
    x = ~non_zero_sum_vars,
    type = "box",
    orientation = "h",
    fillcolor = "orange",
    line = list(color = "darkred")
  ) %>%
    layout(
      title = "Boxplot - Summed Variable",
      xaxis = list(
        title = list(
          text = "sum_vars",
          standoff = 10
        ),
        automargin = TRUE
      ),
      yaxis = list(
        title = NULL,
        showticklabels = FALSE  # Hide tick labels on Y axis
      ),
      margin = list(l = 50, r = 30, t = 60, b = 40),
      showlegend = FALSE
    )
}

# render_summed_boxplot <- function(df) {
#   req(df)
#   
#   if (!"sum_vars" %in% names(df)) {
#     return(NULL)
#   }
#   
#   # Filtrar valores no nulos ni cero
#   non_zero_sum_vars <- df$sum_vars
#   non_zero_sum_vars <- non_zero_sum_vars[!is.na(non_zero_sum_vars) & non_zero_sum_vars != 0]
#   
#   if (length(non_zero_sum_vars) == 0) {
#     return(NULL)
#   }
#   
#   # Crear dataframe para graficar
#   df_plot <- data.frame(sum_vars = non_zero_sum_vars)
#   
#   # Crear gráfico ggplot
#   p <- ggplot(df_plot, aes(x = "", y = sum_vars)) +
#     geom_boxplot(fill = "orange", color = "darkred", width = 0.3) +
#     coord_flip() +
#     scale_y_continuous(
#       labels = scales::label_number(scale_cut = scales::cut_si("B", "M", "K", ""), accuracy = 0.1)
#     ) +
#     labs(
#       title = "Boxplot - Summed Variable",
#       x = NULL,
#       y = "sum_vars"
#     ) +
#     theme_minimal() +
#     theme(
#       axis.text.x = element_text(size = 10),
#       axis.text.y = element_blank(),
#       axis.ticks.y = element_blank(),
#       plot.title = element_text(hjust = 0.5)
#     )
#   
#   ggplotly(p)
# }
# Correlation_KPI.R

# =============================================================================
# Function that renders a correlation plot between the KPI and the sum of variables
# =============================================================================

render_kpi_correlation <- function(df, kpi) {
  # Ensure that the dataframe and KPI are valid
  req(df, kpi)
  validate(
    need(kpi %in% names(df), "KPI not found in the dataset.")
  )
  
  # Attempt to use 'trans_sum_vars'; if not available, fallback to 'sum_vars'
  sum_col <- "trans_sum_vars"
  if (!sum_col %in% names(df)) {
    if ("sum_vars" %in% names(df)) {
      sum_col <- "sum_vars"
    } else {
      return(plot_ly() %>% layout(title = "Sum/transformed column not found."))
    }
  }
  
  kpi_data <- df[[kpi]]
  sum_data <- df[[sum_col]]
  
  # Check for complete cases
  valid_idx <- complete.cases(kpi_data, sum_data)
  if (sum(valid_idx) < 3) {
    return(plot_ly() %>% layout(title = "Not enough data for correlation."))
  }
  
  # Compute correlation
  corr_val <- cor(kpi_data[valid_idx], sum_data[valid_idx], use = "complete.obs")
  
  # Generate scatter plot
  plot_ly(
    x = ~sum_data[valid_idx], 
    y = ~kpi_data[valid_idx], 
    type = 'scatter', 
    mode = 'markers',
    marker = list(color = 'darkgreen', size = 8)
  ) %>%
    layout(
      title = paste("Correlation:", round(corr_val, 2)),
      xaxis = list(
        title = list(
          text = "Sum / Transformed Sum",
          standoff = 20
        ),
        automargin = TRUE
      ),
      yaxis = list(
        title = list(
          text = kpi,
          standoff = 20
        ),
        automargin = TRUE
      ),
      margin = list(l = 70, r = 30, t = 60, b = 60),
      showlegend = FALSE
    )
}
# Correlation_Matrix.R


# Function that renders a correlation matrix between selected variables
render_correlation_matrix <- function(df, input) {
  req(df)
  
  # First, determine which variables are selected and their indices
  var_inputs <- list(
    "1" = input$var1_multi,
    "2" = input$var2_multi,
    "3" = input$var3_multi,
    "4" = input$var4_multi
  )
  
  # Filter out non-selected variables
  selected_vars <- var_inputs[var_inputs != "None"]
  var_columns <- intersect(unlist(selected_vars), names(df))
  
  # Include the KPI if selected and valid
  kpi_var <- NULL
  if (!is.null(input$kpi_multi) && input$kpi_multi != "None" && input$kpi_multi %in% names(df)) {
    kpi_var <- input$kpi_multi
    var_columns <- c(var_columns, kpi_var)
  }
  
  if (length(var_columns) < 2) {
    return(plot_ly() %>% layout(title = "Select at least two variables."))
  }
  
  # Calculate the correlation matrix
  corr_matrix <- cor(df[var_columns], use = "complete.obs")
  
  # Create "Variable X" type labels where X is the original index (1-4)
  display_names <- c()
  for (i in 1:length(var_columns)) {
    var_name <- var_columns[i]
    
    # If it's the KPI, use "KPI"
    if (!is.null(kpi_var) && var_name == kpi_var) {
      display_names[i] <- "KPI"
    } else {
      # Find the original index in var_inputs
      for (j in 1:4) {
        if (var_inputs[[as.character(j)]] == var_name) {
          display_names[i] <- paste("Variable", j)
          break
        }
      }
    }
  }
  
  # Identify the position of the KPI in the matrix
  kpi_index <- which(var_columns == kpi_var)
  
  # Create annotations to display correlation values in each cell
  annotations <- list()
  for (i in 1:length(var_columns)) {
    for (j in 1:length(var_columns)) {
      # Text color: black for regular correlations,
      # green for significant positive correlations with the KPI,
      # red for significant negative correlations with the KPI
      text_color <- "black"
      
      # If we're in a cell involving the KPI and not on the diagonal
      if (length(kpi_index) > 0 && (i == kpi_index || j == kpi_index) && i != j) {
        corr_value <- corr_matrix[i, j]
        if (abs(corr_value) >= 0.5) {
          text_color <- ifelse(corr_value > 0, "darkgreen", "darkred")
        }
      }
      
      annotations[[length(annotations) + 1]] <- list(
        x = display_names[j],
        y = display_names[i],
        text = format(round(corr_matrix[i, j], 2), nsmall = 2),
        showarrow = FALSE,
        font = list(color = text_color, size = 12)
      )
    }
  }
  
  # Customize color scale for correlations
  color_scale <- list(
    c(0, "red"),
    c(0.5, "white"),
    c(1, "blue")
  )
  
  plot_ly(
    x = display_names,
    y = display_names,
    z = corr_matrix,
    type = "heatmap",
    colorscale = color_scale,
    zmin = -1, zmax = 1
  ) %>%
    layout(
      title = list(
        text = "Correlation Matrix",
        y = 0.97  # Slightly lower the title
      ),
      xaxis = list(
        title = "", 
        tickangle = 45, 
        tickfont = list(size = 12),
        automargin = TRUE,  # Automatic margin to avoid overlap
        tickmode = "array",
        tickvals = display_names,
        ticktext = display_names
      ),
      yaxis = list(
        title = "", 
        tickfont = list(size = 12),
        automargin = TRUE,  # Automatic margin to avoid overlap
        tickmode = "array",
        tickvals = display_names,
        ticktext = display_names
      ),
      annotations = annotations,
      margin = list(l = 80, r = 40, t = 60, b = 100, pad = 4),  # Increase margins
      autosize = TRUE
    ) %>%
    config(responsive = TRUE)
}# Data_Processing.R

# =============================================================================
# Handles multivariate data processing (summing or individual transformations).
# =============================================================================

# (A) Summing
process_summed_data <- function(df, input) {
  # Sums selected variables into a new column
  #
  # Args:
  #   df: Dataframe with data
  #   input: Shiny input object to access selected variables
  #
  # Returns:
  #   Dataframe with new sum_vars column
  
  req(df)
  vars_selected <- c(input$var1_multi, input$var2_multi, input$var3_multi)
  if (!is.null(input$var4_multi) && input$var4_multi != "None" && input$var4_multi != "") {
    vars_selected <- c(vars_selected, input$var4_multi)
  }
  vars_selected <- intersect(vars_selected, names(df))
  if (length(vars_selected) < 1) {
    return(df)
  }
  df$sum_vars <- rowSums(df[, vars_selected, drop = FALSE], na.rm = TRUE)
  return(df)
}

# (B) Transform the sum
process_transformed_data <- function(df, input) {
  # Transforms the sum of variables
  #
  # Args:
  #   df: Dataframe with sum_vars column
  #   input: Shiny input object for transformation parameters
  #
  # Returns:
  #   Dataframe with new trans_sum_vars column
  
  req(df, "sum_vars" %in% names(df))
  transformed <- apply_transformation(df$sum_vars,
                                      type   = input$trans_var1, # using trans_var1
                                      alpha  = input$alpha_multi,
                                      beta   = input$beta_multi,
                                      maxval = input$maxval_multi,
                                      decay  = input$decay_multi,
                                      lag    = input$lag_multi)
  df$trans_sum_vars <- transformed
  df
}

# (C) Transform each selected variable individually
process_individual_vars <- function(df, input) {
  # Transforms each selected variable individually.
  # Only var1_multi will apply the transformation chosen in input$trans_var1.
  # Other variables are left in "Linear".
  #
  # Args:
  #   df: Dataframe with data
  #   input: Shiny input object for variables and parameters
  #
  # Returns:
  #   Dataframe with new transformed columns
  
  req(df)

  vars_selected <- c(input$var1_multi, input$var2_multi, input$var3_multi)
  if (!is.null(input$var4_multi) && input$var4_multi != "None") {
    vars_selected <- c(vars_selected, input$var4_multi)
  }
  vars_selected <- intersect(vars_selected, names(df))
  if (length(vars_selected) < 1) {
    return(df)
  }

  for (var_i in vars_selected) {
    # If the variable is the same as var1_multi, use input$trans_var1.
    # Others use "Linear".
    trans_type <- if (var_i == input$var1_multi) {
      input$trans_var1
    } else {
      "Linear"
    }
    
    newcol <- paste0(var_i, "_transformed")
    df[[newcol]] <- apply_transformation(
      df[[var_i]],
      type   = trans_type,
      alpha  = input$alpha_multi,
      beta   = input$beta_multi,
      maxval = input$maxval_multi,
      decay  = input$decay_multi,
      lag    = input$lag_multi
    )
  }

  return(df)
}# Line_Selected_Variables.R

# Function that generates a multi-variable line chart for 4 selected variables,
# synchronizing the time axis according to the period defined in the dataframe.
render_individual_boxplots <- function(df, input) {
  # Verify that the dataframe is not NULL
  req(df)
  
  # Determine the date column: "Period" or "periodo"
  date_col <- if ("Period" %in% names(df)) "Period" else "periodo"
  req(date_col)
  
  # Select variables using inputs
  var_inputs <- c(
    if (!is.null(input$var1_multi)) input$var1_multi else "None",
    if (!is.null(input$var2_multi)) input$var2_multi else "None",
    if (!is.null(input$var3_multi)) input$var3_multi else "None",
    if (!is.null(input$var4_multi)) input$var4_multi else "None"
  )
  
  # Filter out "None" values
  var_inputs <- var_inputs[var_inputs != "None"]
  
  # Intersect with available columns
  vars <- intersect(var_inputs, names(df))
  
  if (length(vars) < 1) {
    return(plot_ly() %>% layout(title = "No variables to plot."))
  }
  
  # Create variable to "Variable X" mapping
  var_mapping <- list()
  
  if (!is.null(input$var1_multi) && input$var1_multi != "None" && input$var1_multi %in% names(df)) {
    var_mapping[[input$var1_multi]] <- "Variable 1"
  }
  
  if (!is.null(input$var2_multi) && input$var2_multi != "None" && input$var2_multi %in% names(df)) {
    var_mapping[[input$var2_multi]] <- "Variable 2"
  }
  
  if (!is.null(input$var3_multi) && input$var3_multi != "None" && input$var3_multi %in% names(df)) {
    var_mapping[[input$var3_multi]] <- "Variable 3"
  }
  
  if (!is.null(input$var4_multi) && input$var4_multi != "None" && input$var4_multi %in% names(df)) {
    var_mapping[[input$var4_multi]] <- "Variable 4"
  }
  
  # Transform dataframe to long format for easier visualization
  df_long <- df %>%
    select(all_of(vars), !!sym(date_col)) %>%
    pivot_longer(
      cols = all_of(vars),
      names_to = "variable",
      values_to = "value"
    )
  
  # Filter NA values and zeros
  df_long <- df_long %>% filter(!is.na(value) & value != 0)
  
  if (nrow(df_long) == 0) {
    return(plot_ly() %>% layout(title = "No non-zero values to plot."))
  }
  
  # Create display_name column with "Variable X" label
  df_long <- df_long %>%
    mutate(display_name = sapply(variable, function(v) {
      if (v %in% names(var_mapping)) {
        return(var_mapping[[v]])
      } else {
        return(v)  # Fallback to original name
      }
    }))
  
  # Format dates
  df_long <- df_long %>%
    mutate(
      year = format(as.Date(get(date_col)), "%Y"),
      quarter = lubridate::quarter(as.Date(get(date_col))),
      month_label = case_when(
        quarter == 1 ~ "01",
        quarter == 2 ~ "04",
        quarter == 3 ~ "07",
        quarter == 4 ~ "10"
      ),
      label = paste0(year, "-", month_label)
    )
  
  # Group by quarterly label and variable
  df_grouped <- df_long %>%
    group_by(label, display_name) %>%
    summarise(value = mean(value, na.rm = TRUE), .groups = "drop")
  
  # Create synchronized line chart with quarterly time axis
  plot_ly(
    data = df_grouped,
    x = ~label,
    y = ~value,
    color = ~display_name,
    type = "scatter",
    mode = "lines+markers"
  ) %>%
    layout(
      title = "Multi-Variable Line Chart",
      xaxis = list(
        title = list(
          text = "Time",
          standoff = 35  # Greater distance between title and axis
        ), 
        type = "category", 
        tickangle = -70,  # Steeper angle for better readability
        tickfont = list(size = 10),  # Slightly smaller font
        automargin = TRUE,
        dtick = 2  # Show every other tick (reduce crowding)
      ),
      yaxis = list(
        title = list(
          text = "Value",
          standoff = 20  # Greater distance between title and axis
        ),
        automargin = TRUE
      ),
      showlegend = TRUE,
      legend = list(
        orientation = "h",
        y = -0.4,  # Position the legend further below
        xanchor = "center",
        x = 0.5
      ),
      margin = list(l = 60, r = 40, t = 50, b = 150),  # Increased bottom margin for date labels
      autosize = TRUE
    ) %>%
    config(responsive = TRUE)
}# Multivariate_Server.R

# =============================================================================
# Main server logic for the multivariate panel.
# =============================================================================

# Additional submodules for plots and transformations
source("R/modules/multivariate/Boxplot.R")
source("R/modules/multivariate/Correlation_KPI.R")
source("R/modules/multivariate/Correlation_Matrix.R")
source("R/modules/multivariate/Data_Processing.R")
source("R/modules/multivariate/Line_Selected_Variables.R")
source("R/modules/multivariate/S_Curve_EDA.R")
source("R/modules/multivariate/Summed_Variables.R")
source("R/modules/multivariate/Transformed_Summed_Variables.R")
source("R/modules/multivariate/Suggested_Max_Value.R")

multivariate_module_server <- function(input, output, session, rv) {
  # Server module for multivariate analysis
  #
  # Args:
  #   input: Shiny input object
  #   output: Shiny output object
  #   session: Shiny session object
  #   rv: Shared reactive values
  
  # Initialize date range inputs when data is loaded
  observe({
    req(rv$filtered_data)
    # Detect date column
    date_col <- if ("Period" %in% names(rv$filtered_data)) "Period" else if ("periodo" %in% names(rv$filtered_data)) "periodo" else NULL
    if (!is.null(date_col)) {
      date_values <- as.Date(rv$filtered_data[[date_col]])
      date_values <- date_values[!is.na(date_values)]
      if (length(date_values) > 0) {
        min_date <- min(date_values, na.rm = TRUE)
        max_date <- max(date_values, na.rm = TRUE)
        updateDateRangeInput(session, "date_range_multi", 
                             start = min_date,
                             end = max_date)
      }
    }
  })
  
  # Reactive dataframe filtered by date and geography
  base_filtered_data <- reactive({
    req(rv$filtered_data, input$geography_multi)
    df <- rv$filtered_data
    date_col <- rv$date_col
    req(date_col)
    
    # Filter by date range if available
    if (!is.null(input$date_range_multi)) {
      df[[date_col]] <- as.Date(df[[date_col]])
      df <- df[df[[date_col]] >= input$date_range_multi[1] & 
                 df[[date_col]] <= input$date_range_multi[2], ]
    }
    
    # Filter by geography
    if (input$geography_multi != "Total" && input$geography_multi != "N/A") {
      geo_col <- if ("Geography" %in% names(df)) "Geography" else if ("Geografia" %in% names(df)) "Geografia" else NULL
      if (!is.null(geo_col)) {
        df <- df %>% filter(.data[[geo_col]] == input$geography_multi)
      }
    } else if (input$geography_multi == "Total") {
      numeric_cols <- names(df)[sapply(df, is.numeric)]
      df[[date_col]] <- as.Date(df[[date_col]])
      df <- df %>%
        group_by(across(all_of(date_col))) %>%
        summarise(across(all_of(numeric_cols), ~ sum(.x, na.rm = TRUE)), .groups = "drop")
    }
    
    df
  })
  
  # Single reactive that returns transformed data:
  # If sum_all_vars == TRUE → sum + transform
  # If sum_all_vars == FALSE → return raw data without transformation
  transformed_data_multi <- reactive({
    df <- base_filtered_data()
    req(df)
    
    if (!is.null(input$sum_all_vars) && input$sum_all_vars == "true") {
      # Step 1: Sum variables
      df_summed <- process_summed_data(df, input)
      # Step 2: Transform the sum
      df_trans <- process_transformed_data(df_summed, input)
      return(df_trans)
    } else {
      # sum_all_vars == "false" → do not transform variables, just return as-is
      return(df)
    }
  })
  
  # Output: Summed Variables Chart (Linear Flighting)
  output$sum_variables_chart <- renderPlotly({
    req(input$sum_all_vars == "true")
    render_sum_variables_chart(transformed_data_multi())
  })
  
  # Output: Transformed Summed Variables Chart
  output$sum_variables_transf_chart <- renderPlotly({
    req(input$sum_all_vars == "true")
    render_transformed_variables_chart(transformed_data_multi())
  })
  
  # Output: S-Curve EDA
  output$s_curve_multivariate_plot <- renderPlotly({
    req(input$sum_all_vars == "true")
    render_s_curve_multi(transformed_data_multi(), input)
  })
  
  # Output: Boxplot of Summed Variable
  output$boxplot_multi_sum <- renderPlotly({
    req(input$sum_all_vars == "true")
    render_summed_boxplot(transformed_data_multi())
  })
  
  # Output: Suggested Max Value
  output$transformations_summary_multi <- renderPrint({
    req(input$sum_all_vars == "true")
    render_transformations_summary_multi(base_filtered_data(), input)
  })
  
  # Output: Correlation with KPI (for Summed approach)
  output$corr_with_kpi_multi_sum <- renderPlotly({
    req(input$sum_all_vars == "true")
    render_kpi_correlation(transformed_data_multi(), input$kpi_multi)
  })
  
  # If user chooses not to sum:
  # Show individual transformed variables + correlation matrix
  output$boxplot_multi <- renderPlotly({
    req(input$sum_all_vars == "false")
    render_individual_boxplots(base_filtered_data(), input)
  })
  
  output$corr_matrix_multi <- renderPlotly({
    req(input$sum_all_vars == "false")
    render_correlation_matrix(base_filtered_data(), input)
  })
}
# Suggested_Max_Value_Multivariate.R

# =============================================================================
# Displays some suggested maximum value percentages for s-curves or 
# general transformations in multivariate mode.
# =============================================================================

render_transformations_summary_multi <- function(df, input) {
  #' Generates suggestions for transformation parameters in multivariate mode.
  #'
  #' Args:
  #'   df: Dataframe containing the data.
  #'   input: Shiny input object with variable selections.
  #'
  #' Returns:
  #'   Text with parameter suggestions.
  
  req(df)
  
  # Check if we are in sum or individual mode
  if (input$sum_all_vars == "true") {
    # Sum mode - we need to calculate the sum first
    vars_selected <- c(input$var1_multi, input$var2_multi, input$var3_multi)
    if (!is.null(input$var4_multi) && input$var4_multi != "None" && input$var4_multi != "") {
      vars_selected <- c(vars_selected, input$var4_multi)
    }
    vars_selected <- vars_selected[vars_selected != "None"]
    vars_selected <- intersect(vars_selected, names(df))  # Ensure selected vars exist in df
    
    if (length(vars_selected) < 1) {
      cat("No variables selected for calculating suggestions.\n")
      return()
    }
    
    # Calculate the sum of the selected variables
    df$sum_vars <- rowSums(df[, vars_selected, drop = FALSE], na.rm = TRUE)
    box_data <- df$sum_vars
  } else {
    # Individual mode - use the first variable
    if (is.null(input$var1_multi) || input$var1_multi == "None") {
      cat("Please select a valid variable for the summary.\n")
      return()
    }
    
    box_data <- df[[input$var1_multi]]
  }
  
  box_data <- box_data[!is.na(box_data)]
  
  if (length(box_data) == 0) {
    cat("Not enough data to calculate suggestions.\n")
    return()
  }

  data_mean <- mean(box_data, na.rm = TRUE)
  data_sd   <- sd(box_data,   na.rm = TRUE)
  box_max   <- max(box_data,  na.rm = TRUE)

  # Boxplot outlier-based approach
  q1 <- quantile(box_data, 0.25, na.rm = TRUE)
  q3 <- quantile(box_data, 0.75, na.rm = TRUE)
  iqr <- q3 - q1
  upper_limit <- q3 + 1.5 * iqr
  max_not_outlier <- ifelse(box_max > upper_limit, upper_limit, box_max)
  maxval_percent_boxplot <- (max_not_outlier / box_max) * 100

  # 3 standard deviations approach
  three_sd_value <- data_mean + 3 * data_sd
  maxval_percent_three_sd <- (three_sd_value / box_max) * 100

  # Average between mean and max
  avg_mean_max <- (data_mean + box_max) / 2
  maxval_percent_avg <- (avg_mean_max / box_max) * 100
  
  cat("%MaxVal Suggestions:\n")
  cat("Boxplot-based (cap non-outlier):", round(maxval_percent_boxplot, 2), "%\n")
  cat("Three Standard Deviations:",          round(maxval_percent_three_sd, 2), "%\n")
  cat("Average of Mean and Maximum:",       round(maxval_percent_avg, 2), "%\n")
  
}# Summed_Variables.R

# =============================================================================
# Function that renders a flighting chart for summed variables
# =============================================================================

render_sum_variables_chart <- function(df) {
  req(df)
  if (!"sum_vars" %in% names(df)) {
    return(NULL)
  }
  
  date_col <- if ("Period" %in% names(df)) "Period" else "periodo"
  req(date_col)
  
  # # Summarize by quarter, labeling with the initial month (01, 04, 07, 10)
  # df2 <- df %>%
  #   mutate(
  #     year = format(as.Date(.data[[date_col]]), "%Y"),
  #     quarter = lubridate::quarter(as.Date(.data[[date_col]])),
  #     month_label = case_when(
  #       quarter == 1 ~ "01",
  #       quarter == 2 ~ "04",
  #       quarter == 3 ~ "07",
  #       quarter == 4 ~ "10"
  #     ),
  #     label = paste0(year, "-", month_label)
  #   ) %>%
  #   group_by(label) %>%
  #   summarise(sum_vars = sum(sum_vars, na.rm = TRUE), .groups = "drop")
  # 
  # plot_ly(
  #   df2,
  #   x = ~label,
  #   y = ~sum_vars,
  #   type = 'scatter',
  #   mode = 'lines+markers',
  #   line = list(color = 'blue'),
  #   marker = list(color = 'blue')
  # ) %>%
  #   layout(
  #     title = "Summed Variables - Linear Flighting",
  #     xaxis = list(
  #       title = list(
  #         text = "Time",
  #         standoff = 35  # Increase distance between title and axis values
  #       ),
  #       type = "category",
  #       tickangle = -70,  # Steeper angle to prevent overlapping
  #       tickfont = list(size = 10),  # Smaller font for tick labels
  #       automargin = TRUE,  # Auto-adjust margins to prevent overlap
  #       nticks = max(8, floor(length(unique(df2$label)) / 2))  # Show fewer tick labels
  #     ),
  #     yaxis = list(
  #       title = list(
  #         text = "Summed Value",
  #         standoff = 20  # Increase distance between title and axis values
  #       ),
  #       automargin = TRUE  # Auto-adjust margins to prevent overlap
  #     ),
  #     margin = list(l = 70, r = 40, t = 60, b = 120),  # Increased bottom margin
  #     showlegend = FALSE
  #   )
  # Preparar los datos con la fecha real
  df2 <- df %>%
    mutate(
      date = as.Date(.data[[date_col]])
    ) %>%
    arrange(date)
  
  # Gráfico con fechas reales y eje X cada 3 meses
  plot_ly(
    df2,
    x = ~date,
    y = ~sum_vars,
    type = 'scatter',
    mode = 'lines+markers',
    line = list(color = 'blue'),
    marker = list(color = 'blue'),
    hovertemplate = paste(
      "Date: %{x|%Y-%m-%d}<br>",
      "Summed Value: %{y:,.2f}<extra></extra>"
    )
  ) %>%
    layout(
      title = "Summed Variables - Linear Flighting",
      xaxis = list(
        title = list(text = "Time", standoff = 35),
        type = "date",
        tickformat = "%Y-%m",
        dtick = "M3",
        tickangle = -70,
        tickfont = list(size = 10),
        automargin = TRUE
      ),
      yaxis = list(
        title = list(text = "Summed Value", standoff = 20),
        automargin = TRUE
      ),
      margin = list(l = 70, r = 40, t = 60, b = 120),
      showlegend = FALSE
    )
  
}
# S_Curve_EDA_Multivariate.R

# -------------------------------------------------------------------------#
# Module for Multivariate Render (S-Curve EDA)
# -------------------------------------------------------------------------

source("R/modules/common/s_curve_charts.R")
source("R/modules/common/s_curve_helpers.R")
source("R/modules/multivariate/Suggested_Max_Value.R")  # Import Suggested Max Value file for multivariate
library(dplyr)
library(shiny)
library(plotly)
library(shinycssloaders)

# -------------------------------------------------------------------------
# render_s_curve_multi: Renders the Multivariate S-Curve and Flighting charts
# -------------------------------------------------------------------------
render_s_curve_multi <- function(df, input) {
  req(df)
 
  validate(
    need(input$trans_var1 %in% c("S Origin", "S Shaped"),
         "This chart (Multivariate) is only displayed for 'S Origin' or 'S Shaped'.")
  )
 
  if (!"sum_vars" %in% names(df)) {
    return(plot_ly() %>% layout(title = "Column 'sum_vars' not found in df."))
  }
 
  # Use data already filtered with global date filter
  s_data <- df %>%
    select(Period, sum_vars) %>%
    rename(value = sum_vars) %>%
    mutate(Period = as.Date(Period))
 
  # Data for average calculation (green line)
  avg_data <- NULL
  avg_period <- 52  # Default value
  
  # Check if we have a date range selected for average calculation
  if (!is.null(input$avg_period_date_multi) && 
      length(input$avg_period_date_multi) == 2 && 
      !is.na(input$avg_period_date_multi[1]) && 
      !is.na(input$avg_period_date_multi[2])) {
      
    # Filter data for average calculation, excluding zeros
    avg_data <- s_data %>%
      filter(Period >= input$avg_period_date_multi[1] & 
             Period <= input$avg_period_date_multi[2] &
             value > 0)  # Exclude zeros
    
    # Only update avg_period if there's data in the range
    if (nrow(avg_data) > 0) {
      avg_period <- nrow(avg_data)
    } else {
      # If no data in range, clear avg_data to use the average of the whole series
      avg_data <- NULL
    }
  }
  
  # Verify we have data for average calculation
  if (is.null(avg_data)) {
    # Use all non-zero values if no specific data
    avg_period <- nrow(s_data %>% filter(value > 0))
  }
 
  alpha       <- input$alpha_multi
  beta        <- input$beta_multi
  max_val_pct <- input$maxval_multi
  decay       <- input$decay_multi
  lag         <- input$lag_multi
 
  # First generate Flighting Chart to get its configurations
  flighting_plot <- tryCatch({
    create_flighting_chart(
      data_chart = s_data,
      alpha = alpha,
      beta = beta,
      max_val_pct = max_val_pct,
      decay = decay,
      lag = lag,
      var_name = "Multivariate Sum",
      calculated_key_points = NULL,  # No key points yet
      avg_period = avg_period,
      avg_data = avg_data  # Pass filtered data for average calculation
    )
  }, error = function(e) {
    return(plot_ly() %>% layout(title = paste("Error in Multivariate Flighting:", e$message)))
  })
  
  # Then generate S-Curve using Flighting Chart configurations
  s_curve_plot <- tryCatch({
    create_s_curve_chart(
      data_chart = s_data,
      alpha = alpha,
      beta = beta,
      max_val_pct = max_val_pct,
      decay = decay,
      lag = lag,
      var_name = "Multivariate Sum",
      avg_period = avg_period,
      avg_data = avg_data,  # Pass filtered data for average calculation
      flighting_chart = flighting_plot  # Pass flighting chart to coordinate axes
    )
  }, error = function(e) {
    return(plot_ly() %>% layout(title = paste("Error in Multivariate S-Curve:", e$message)))
  })
  
  # Get key points from S-Curve
  key_points <- attr(s_curve_plot, "key_points")
  
  # Recreate Flighting Chart with S-Curve key points
  flighting_plot <- tryCatch({
    create_flighting_chart(
      data_chart = s_data,
      alpha = alpha,
      beta = beta,
      max_val_pct = max_val_pct,
      decay = decay,
      lag = lag,
      var_name = "Multivariate Sum",
      calculated_key_points = key_points,  # Use key points from S-Curve
      avg_period = avg_period,
      avg_data = avg_data  # Pass filtered data for average calculation
    )
  }, error = function(e) {
    return(plot_ly() %>% layout(title = paste("Error in Multivariate Flighting:", e$message)))
  })
 
  subplot(flighting_plot, s_curve_plot, nrows = 1, widths = c(0.7, 0.3), titleX = TRUE, titleY = TRUE, margin = 0.05) %>%
    layout(
      title = "",  # Remove title
      margin = list(l = 60, r = 60, b = 60, t = 10, pad = 10),  # Reduce top margin
      autosize = TRUE,
      plot_bgcolor = '#FFFFFF',
      paper_bgcolor = '#FFFFFF',
      font = list(family = "Arial, sans-serif"),
      hoverlabel = list(bgcolor = "#FFF", font = list(size = 12, family = "Arial, sans-serif"), bordercolor = "#DDD")
    ) %>%
    config(displayModeBar = TRUE, displaylogo = FALSE, modeBarButtonsToRemove = list('sendDataToCloud', 'hoverCompareCartesian', 'hoverClosestCartesian', 'select2d', 'lasso2d'), responsive = TRUE)
}

# -------------------------------------------------------------------------
# prep_multi_data: Prepares multivariate data for analysis
# -------------------------------------------------------------------------
prep_multi_data <- function(df, input) {
  req(df)
 
  # Filter by global date range if available
  if (!is.null(input$date_filter_multi)) {
    date_col <- if ("Period" %in% names(df)) "Period" else if ("periodo" %in% names(df)) "periodo" else NULL
    if (!is.null(date_col)) {
      df[[date_col]] <- as.Date(df[[date_col]])
      df <- df[df[[date_col]] >= input$date_filter_multi[1] &
              df[[date_col]] <= input$date_filter_multi[2], ]
    }
  }
 
  all_vars <- c(input$var1, input$var2, input$var3, input$var4, input$var5, input$var6)
  vars <- all_vars[!is.na(all_vars) & all_vars != "N/A"]
 
  if (length(vars) == 0) return(NULL)
 
  transforms <- c(input$trans_var1, input$trans_var2, input$trans_var3, input$trans_var4, input$trans_var5, input$trans_var6)[!is.na(all_vars) & all_vars != "N/A"]
  weights <- c(input$weight_var1, input$weight_var2, input$weight_var3, input$weight_var4, input$weight_var5, input$weight_var6)[!is.na(all_vars) & all_vars != "N/A"]
 
  result_df <- df %>% mutate(Period = if ("Period" %in% names(.)) as.Date(Period) else as.Date(periodo))
 
  for (i in seq_along(vars)) {
    var_name <- vars[i]
    trans_type <- transforms[i]
    weight <- weights[i]
    var_values <- result_df[[var_name]]
    transformed_values <- apply_transformation(var_values, type = trans_type, alpha = input$alpha_multi, beta = input$beta_multi, maxval = input$maxval_multi, decay = input$decay_multi, lag = input$lag_multi)
    result_df[[paste0(var_name, "_transformed")]] <- transformed_values * weight
  }
 
  transformed_cols <- paste0(vars, "_transformed")
  result_df$sum_vars <- rowSums(result_df[transformed_cols], na.rm = TRUE)
 
  return(result_df)
}

# -------------------------------------------------------------------------
# ui_s_curve_eda_multivariate: UI for the S-Curve EDA module (Multivariate)
# -------------------------------------------------------------------------
ui_s_curve_eda_multivariate <- function(id) {
  ns <- NS(id)
 
  fluidPage(
    fluidRow(
      column(3,
             wellPanel(
               style = "background-color: #f9f9f9; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.1);",
               h4("Global Parameters", style = "font-weight: bold; color: #333; border-bottom: 1px solid #ddd; padding-bottom: 8px;"),
               sliderInput(ns("alpha_multi"), "Alpha:", min = 0.01, max = 0.99, value = 0.85, step = 0.01, width = "100%"),
               sliderInput(ns("beta_multi"), "Beta:", min = 0.01, max = 10, value = 1, step = 0.01, width = "100%"),
               sliderInput(ns("maxval_multi"), "Max Value %:", min = 50, max = 200, value = 100, step = 5, width = "100%"),
               sliderInput(ns("decay_multi"), "Decay:", min = 0.01, max = 5, value = 1, step = 0.01, width = "100%"),
               numericInput(ns("lag_multi"), "Lag (periods):", min = 0, max = 100, value = 0, step = 1, width = "100%"),
               
               # Selector for average period (ONLY affects green line calculation)
               conditionalPanel(
                 condition = paste0("input['", ns("trans_var1"), "'] == 'S Origin' || input['", ns("trans_var1"), "'] == 'S Shaped'"),
                 div(style = "margin-top: 15px;",
                     h4("Average Period Selection", style = "font-weight: bold; color: #333; border-bottom: 1px solid #ddd; padding-bottom: 8px;"),
                     dateRangeInput(ns("avg_period_date_multi"), "Select Date Range for Average:",
                                    start = Sys.Date() - 365,
                                    end = Sys.Date(),
                                    separator = " to "),
                     helpText("This range ONLY affects the average calculation (green line)"),
                     # Specific button to update average
                     actionButton(ns("update_avg_multi"), "Update Average", 
                                 class = "btn-primary btn-block", 
                                 style = "margin-top: 10px;")
                 )
               ),
               
               # Download button
               div(style = "margin-top: 15px; text-align: center;",
                   downloadButton(ns("download_multivariate"), "Download Transformed Data",
                                 class = "btn-primary btn-block custom-download-btn",
                                 icon = icon("download"))
               ),
               
               hr(),
               h4("Variables", style = "font-weight: bold; color: #333; border-bottom: 1px solid #ddd; padding-bottom: 8px;")
             ),
             wellPanel(
               style = "background-color: #f3f8ff; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); margin-top: 10px;",
               h4("Variable 1", style = "color: #0066cc;"),
               selectInput(ns("var1"), "Select:", choices = c("Select" = "N/A"), width = "100%"),
               selectInput(ns("trans_var1"), "Transformation:", choices = c("Linear", "S Origin", "S Shaped", "Index Exp", "Log", "Exp", "Power", "Moving Avg"), selected = "S Origin", width = "100%"),
               sliderInput(ns("weight_var1"), "Weight:", min = 0, max = 10, value = 1, step = 0.1, width = "100%")
             ),
             lapply(2:6, function(i) {
               wellPanel(
                 style = paste0("background-color: #f", i, "f", i+2, "ff; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); margin-top: 10px;"),
                 h4(paste("Variable", i), style = paste0("color: #00", i, "6cc;")),
                 selectInput(ns(paste0("var", i)), "Select:", choices = c("Select" = "N/A", "None" = NA), width = "100%"),
                 selectInput(ns(paste0("trans_var", i)), "Transformation:", choices = c("Linear", "S Origin", "S Shaped", "Index Exp", "Log", "Exp", "Power", "Moving Avg"), selected = "S Origin", width = "100%"),
                 sliderInput(ns(paste0("weight_var", i)), "Weight:", min = 0, max = 10, value = 1, step = 0.1, width = "100%")
               )
             })
      ),
      column(9,
             # Add panel for Suggested Max Value
             wellPanel(
               style = "background-color: white; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); padding: 15px; margin-bottom: 15px;",
               h4("Suggested Max Value", style = "font-weight: bold; color: #333; margin-top: 0;"),
               verbatimTextOutput(ns("transformations_summary_multi"))
             ),
             div(
               class = "chart-box",
               style = "background-color: white; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); padding: 15px; height: 700px;",
               plotlyOutput(ns("s_curve_multi_plot"), height = "100%") %>% withSpinner(color = "#0275d8", type = 5)
             )
      )
    )
  )
}

# -------------------------------------------------------------------------
# server_s_curve_eda_multivariate: Server for the S-Curve EDA module (Multivariate)
# -------------------------------------------------------------------------
server_s_curve_eda_multivariate <- function(id, df, var_choices) {
  moduleServer(id, function(input, output, session) {
    observe({
      req(var_choices())
      var_opts <- c("Select" = "N/A", var_choices())
      var_opts_with_none <- c("Select" = "N/A", "None" = NA, var_choices())
      updateSelectInput(session, "var1", choices = var_opts)
      lapply(2:6, function(i) updateSelectInput(session, paste0("var", i), choices = var_opts_with_none))
    })
   
    # Initialize date values for both selectors
    observe({
      req(df())
      # Detect date column
      date_col <- if ("Period" %in% names(df())) "Period" else if ("periodo" %in% names(df())) "periodo" else NULL
      if (!is.null(date_col)) {
        date_values <- as.Date(df()[[date_col]])
        date_values <- date_values[!is.na(date_values)]
        if (length(date_values) > 0) {
          min_date <- min(date_values, na.rm = TRUE)
          max_date <- max(date_values, na.rm = TRUE)
          # Update both date selectors
          updateDateRangeInput(session, "date_filter_multi",
                              start = min_date,
                              end = max_date)
          updateDateRangeInput(session, "avg_period_date_multi",
                              start = min_date,
                              end = max_date)
        }
      }
    })
   
    multi_data <- reactive({
      req(df(), input$var1 != "N/A", input$trans_var1)
      prep_multi_data(df(), input)
    })
    
    # Reactive value to force chart update
    update_trigger <- reactiveVal(0)
    
    # Specific observer for update button
    observeEvent(input$update_avg_multi, {
      update_trigger(update_trigger() + 1)
    }, ignoreInit = TRUE)
    
    # Observer for changes in parameters that affect the chart
    observe({
      # List of inputs that should trigger an update
      input$alpha_multi
      input$beta_multi
      input$maxval_multi
      input$decay_multi
      input$lag_multi
      input$var1
      input$trans_var1
      update_trigger() # Include update trigger
      
      # Update chart only if we have data
      if (!is.null(multi_data())) {
        # Render chart
        output$s_curve_multi_plot <- renderPlotly({
          render_s_curve_multi(multi_data(), input)
        })
      }
    })
   
    # Render initial chart
    output$s_curve_multi_plot <- renderPlotly({
      req(multi_data())
      render_s_curve_multi(multi_data(), input)
    })
   
    # Render Suggested Max Value for multivariate transformations
    output$transformations_summary_multi <- renderPrint({
      req(df(), input$var1 != "N/A")
      render_transformations_summary_multi(df(), input)
    })
   
    # Link download button to correct handler based on mode
    observe({
      if (input$sum_all_vars == "true") {
        # Download in sum mode
        output$download_multivariate <- downloadHandler(
          filename = function() {
            paste0("multivariate_summed_", Sys.Date(), ".csv")
          },
          content = function(file) {
            # Implementation in multivariate_download_handler
          }
        )
      } else {
        # Download in individual mode
        output$download_multivariate <- downloadHandler(
          filename = function() {
            paste0("multivariate_individual_", Sys.Date(), ".csv")
          },
          content = function(file) {
            # Implementation in multivariate_download_handler
          }
        )
      }
    })
  })
}# Transformed_Summed_Variables.R


# Function that renders a chart for transformed summed variables
render_transformed_variables_chart <- function(df) {
  req(df)
  if (!"trans_sum_vars" %in% names(df)) {
    return(NULL)
  }
  
  date_col <- if ("Period" %in% names(df)) "Period" else "periodo"
  req(date_col)
  
  # # Summarize by quarter, labeling with the initial month of the quarter
  # df2 <- df %>%
  #   mutate(
  #     year = format(as.Date(.data[[date_col]]), "%Y"),
  #     quarter = lubridate::quarter(as.Date(.data[[date_col]])),
  #     month_label = case_when(
  #       quarter == 1 ~ "01",
  #       quarter == 2 ~ "04",
  #       quarter == 3 ~ "07",
  #       quarter == 4 ~ "10"
  #     ),
  #     label = paste0(year, "-", month_label)
  #   ) %>%
  #   group_by(label) %>%
  #   summarise(trans_sum_vars = sum(trans_sum_vars, na.rm = TRUE), .groups = "drop")
  # 
  # plot_ly(
  #   df2, 
  #   x = ~label, 
  #   y = ~trans_sum_vars,
  #   type = 'scatter', 
  #   mode = 'lines+markers',
  #   line = list(color = 'red'),
  #   marker = list(color = 'red')
  # ) %>%
  #   layout(
  #     title = "Transformed Summed Variables",
  #     xaxis = list(
  #       title = list(
  #         text = "Time",
  #         standoff = 35  # Increase distance between title and axis values
  #       ),
  #       type = "category", 
  #       tickangle = -70,  # Steeper angle to prevent overlapping
  #       tickfont = list(size = 10),  # Smaller font for tick labels
  #       automargin = TRUE,  # Auto-adjust margins to prevent overlap
  #       nticks = max(8, floor(length(unique(df2$label))/2))  # Show fewer tick labels
  #     ),
  #     yaxis = list(
  #       title = list(
  #         text = "Transformed Sum",
  #         standoff = 20  # Increase distance between title and axis values
  #       ),
  #       automargin = TRUE  # Auto-adjust margins to prevent overlap
  #     ),
  #     margin = list(l = 70, r = 40, t = 60, b = 120),  # Increased bottom margin
  #     showlegend = FALSE
  #   )
  # Preparar los datos con fecha real
  df2 <- df %>%
    mutate(
      date = as.Date(.data[[date_col]])
    ) %>%
    arrange(date)
  
  # Crear gráfico con fechas reales y eje limpio
  plot_ly(
    df2, 
    x = ~date, 
    y = ~trans_sum_vars,
    type = 'scatter', 
    mode = 'lines+markers',
    line = list(color = 'red'),
    marker = list(color = 'red'),
    hovertemplate = paste(
      "Date: %{x|%Y-%m-%d}<br>",
      "Transformed Sum: %{y:,.2f}<extra></extra>"
    )
  ) %>%
    layout(
      title = "Transformed Summed Variables",
      xaxis = list(
        title = list(text = "Time", standoff = 35),
        type = "date",
        tickformat = "%Y-%m",
        dtick = "M3",
        tickangle = -70,
        tickfont = list(size = 10),
        automargin = TRUE
      ),
      yaxis = list(
        title = list(text = "Transformed Sum", standoff = 20),
        automargin = TRUE
      ),
      margin = list(l = 70, r = 40, t = 60, b = 120),
      showlegend = FALSE
    )
  
}# =============================================================================
# Boxplot for Univariate tab.
# =============================================================================

# Function that generates a boxplot for 'sum_vars' ignoring NA and zeros,
# in horizontal orientation.
render_summed_boxplot <- function(df) {
  req(df)
  
  if (!"sum_vars" %in% names(df)) {
    return(plot_ly() %>% layout(title = "Column 'sum_vars' does not exist."))
  }
  
  non_zero_sum_vars <- df$sum_vars
  non_zero_sum_vars <- non_zero_sum_vars[!is.na(non_zero_sum_vars) & non_zero_sum_vars != 0]
  
  if (length(non_zero_sum_vars) == 0) {
    return(plot_ly() %>% layout(title = "No non-zero data in 'sum_vars'."))
  }
  
  plot_ly(
    x = ~non_zero_sum_vars,
    type = "box",
    orientation = "h",
    fillcolor = "orange",
    line = list(color = "darkred"),
    hovertemplate = "Value: %{x:.2s}<extra></extra>"
  ) %>%
    layout(
      title = "Boxplot - Summed Variable",
      xaxis = list(
        title = list(text = "sum_vars", standoff = 10),
        tickformat = ".2s",      # <- Esta es la clave correcta
        automargin = TRUE
      ),
      yaxis = list(
        title = NULL,
        showticklabels = FALSE
      ),
      margin = list(l = 50, r = 30, t = 60, b = 40),
      showlegend = FALSE
    )
}
# 
# render_boxplot_univariate <- function(df, variable_univ, geography_univ) {
#   req(df, variable_univ)
# 
#   validate(
#     need(variable_univ != "N/A", "Please select a valid variable for the boxplot.")
#   )
# 
#   box_data <- df[[variable_univ]]
#   box_data <- box_data[!is.na(box_data) & box_data != 0]
# 
#   validate(
#     need(length(box_data) > 0, "No non-zero data available for the boxplot.")
#   )
# 
#   ggplot(data.frame(val = box_data), aes(x = val)) +
#     geom_boxplot(
#       fill = "#4682B4",
#       color = "#2F4F4F",
#       alpha = 0.8,
#       outlier.shape = 21,
#       outlier.fill = "white",
#       outlier.color = "#2F4F4F"
#     ) +
#     coord_flip() +
#     theme_minimal() +
#     theme(
#       plot.title = element_text(size = 14, face = "bold", hjust = 0, margin = margin(b = 10)),
#       axis.title = element_text(size = 11, face = "bold", color = "#303030"),
#       axis.text = element_text(size = 10, color = "#505050"),
#       panel.grid.major = element_line(color = "#ECECEC"),
#       panel.grid.minor = element_blank(),
#       panel.background = element_rect(fill = "white"),
#       plot.background = element_rect(fill = "white", color = NA),
#       plot.margin = margin(t = 10, r = 20, b = 10, l = 40)
#     ) +
#     labs(
#       title = paste("Boxplot (Geography:", geography_univ, ")"),
#       x = variable_univ,
#       y = NULL
#     )
# }
# 
library(ggplot2)
library(scales)

render_boxplot_univariate <- function(df, variable_univ, geography_univ) {
  req(df, variable_univ)
  
  validate(
    need(variable_univ != "N/A", "Please select a valid variable for the boxplot.")
  )
  
  box_data <- df[[variable_univ]]
  box_data <- box_data[!is.na(box_data) & box_data != 0]
  
  validate(
    need(length(box_data) > 0, "No non-zero data available for the boxplot.")
  )
  
  ggplot(data.frame(val = box_data), aes(x = val)) +
    geom_boxplot(
      fill = "#4682B4",
      color = "#2F4F4F",
      alpha = 0.8,
      outlier.shape = 21,
      outlier.fill = "white",
      outlier.color = "#2F4F4F"
    ) +
    coord_flip() +
    theme_minimal() +
    theme(
      plot.title = element_text(size = 14, face = "bold", hjust = 0, margin = margin(b = 10)),
      axis.title = element_text(size = 11, face = "bold", color = "#303030"),
      axis.text = element_text(size = 10, color = "#505050"),
      panel.grid.major = element_line(color = "#ECECEC"),
      panel.grid.minor = element_blank(),
      panel.background = element_rect(fill = "white"),
      plot.background = element_rect(fill = "white", color = NA),
      plot.margin = margin(t = 10, r = 20, b = 10, l = 40)
    ) +
    scale_x_continuous(labels = label_number(scale_cut = cut_short_scale())) +
    labs(
      title = paste("Boxplot (Geography:", geography_univ, ")"),
      x = variable_univ,
      y = NULL
    )
}

# Data_Filtering.R

# =============================================================================
# Filtering logic for univariate analysis, specifically by geography.
# =============================================================================

filter_geography_data <- function(data, geography_univ) {
  # Filters the dataframe by the selected geography
  #
  # Args:
  #   data: Dataframe to filter
  #   geography_univ: Selected geography value
  #
  # Returns:
  #   Dataframe filtered by geography
  
  req(data, geography_univ)
  df <- data
  date_col <- if ("Period" %in% names(df)) "Period" else if ("periodo" %in% names(df)) "periodo" else NULL
  req(date_col)

  if (geography_univ != "Total" && geography_univ != "N/A") {
    geo_col <- if ("Geography" %in% names(df)) "Geography" else if ("Geografia" %in% names(df)) "Geografia" else NULL
    if (!is.null(geo_col)) {
      df <- df %>% filter(.data[[geo_col]] == geography_univ)
    }
  } else if (geography_univ == "Total") {
    numeric_cols <- names(df)[sapply(df, is.numeric)]
    df <- df %>%
      group_by(across(all_of(date_col))) %>%
      summarise(across(all_of(numeric_cols), ~ sum(.x, na.rm = TRUE)), .groups = "drop")
  }

  return(df)
}# # KPI_Variable_Correlation.R
# 
# # =============================================================================
# # Renders the correlation chart between KPI and (optionally) transformed variable
# # =============================================================================
# 
# render_correlation_plot <- function(df, kpi_univ, variable_univ,
#                                     transformation_univ, lag_univ, decay_univ,
#                                     alpha_univ, beta_univ, maxval_univ) {
#   # Generates a correlation chart between KPI and (transformed) variable
#   #
#   # Args:
#   #   df: Dataframe with data
#   #   kpi_univ: Name of the KPI variable
#   #   variable_univ: Name of the variable to transform
#   #   transformation_univ, lag_univ, decay_univ, alpha_univ, beta_univ, maxval_univ:
#   #     Transformation parameters
#   #
#   # Returns:
#   #   plotly chart with correlation
# 
#   req(df, kpi_univ, variable_univ, transformation_univ)
#   validate(
#     need(variable_univ != "N/A", "Please select a valid variable for correlation.")
#   )
# 
#   kpi_data <- df[[kpi_univ]]
#   var_data <- df[[variable_univ]]
# 
#   if (sum(!is.na(var_data)) < 5) {
#     plot.new()
#     title("Insufficient data for correlation.")
#     return()
#   }
# 
#   # Apply same transformation to var_data
#   data_trans <- apply_transformation(var_data,
#                                      type   = transformation_univ,
#                                      alpha  = alpha_univ,
#                                      beta   = beta_univ,
#                                      maxval = maxval_univ,
#                                      decay  = decay_univ,
#                                      lag    = lag_univ)
# 
#   valid_idx <- complete.cases(kpi_data, data_trans)
#   if (sum(valid_idx) < 5) {
#     plot.new()
#     title("Not enough complete data points for correlation.")
#     return()
#   }
# 
#   corr_val <- tryCatch({
#     if (sd(kpi_data[valid_idx], na.rm = TRUE) == 0 ||
#         sd(data_trans[valid_idx], na.rm = TRUE) == 0) {
#       NA
#     } else {
#       cor(kpi_data[valid_idx], data_trans[valid_idx], use = "complete.obs")
#     }
#   }, error = function(e) {
#     notifyUser(paste("Error calculating correlation:", e$message), "error")
#     NA
#   })
# 
#   # Build a ggplot
#   df_plot <- data.frame(KPI = kpi_data[valid_idx], Variable = data_trans[valid_idx])
#   p <- ggplot(df_plot, aes(x = KPI, y = Variable)) +
#     geom_point(color = "darkblue") +
#     theme_minimal() +
#     theme(
#       plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
#       axis.title = element_text(size = 11, face = "bold", margin = margin(t = 10, r = 10, b = 10, l = 10)),
#       axis.text = element_text(size = 10),
#       plot.margin = margin(t = 20, r = 20, b = 20, l = 20)  # Increased margins all around
#     ) +
#     labs(
#       title = paste("Correlation:", ifelse(is.na(corr_val), "NA", round(corr_val, 2))),
#       x = kpi_univ,
#       y = paste(variable_univ, "(Transformed)")
#     )
# 
#   # Convert to plotly with increased margins to prevent overlapping
#   ggplotly(p) %>%
#     layout(
#       autosize = TRUE,
#       margin = list(l = 80, r = 40, t = 60, b = 80),
#       xaxis = list(automargin = TRUE),
#       yaxis = list(automargin = TRUE)
#     )
# }

library(ggplot2)
library(scales)
library(plotly)

render_correlation_plot <- function(df, kpi_univ, variable_univ,
                                    transformation_univ, lag_univ, decay_univ,
                                    alpha_univ, beta_univ, maxval_univ) {
  req(df, kpi_univ, variable_univ, transformation_univ)
  
  validate(
    need(variable_univ != "N/A", "Please select a valid variable for correlation.")
  )
  
  kpi_data <- df[[kpi_univ]]
  var_data <- df[[variable_univ]]
  
  if (sum(!is.na(var_data)) < 5) {
    plot.new()
    title("Insufficient data for correlation.")
    return()
  }
  
  data_trans <- apply_transformation(var_data,
                                     type   = transformation_univ,
                                     alpha  = alpha_univ,
                                     beta   = beta_univ,
                                     maxval = maxval_univ,
                                     decay  = decay_univ,
                                     lag    = lag_univ)
  
  valid_idx <- complete.cases(kpi_data, data_trans)
  if (sum(valid_idx) < 5) {
    plot.new()
    title("Not enough complete data points for correlation.")
    return()
  }
  
  corr_val <- tryCatch({
    if (sd(kpi_data[valid_idx], na.rm = TRUE) == 0 ||
        sd(data_trans[valid_idx], na.rm = TRUE) == 0) {
      NA
    } else {
      cor(kpi_data[valid_idx], data_trans[valid_idx], use = "complete.obs")
    }
  }, error = function(e) {
    notifyUser(paste("Error calculating correlation:", e$message), "error")
    NA
  })
  
  df_plot <- data.frame(KPI = kpi_data[valid_idx], Variable = data_trans[valid_idx])
  
  p <- ggplot(df_plot, aes(x = KPI, y = Variable)) +
    geom_point(color = "darkblue") +
    theme_minimal() +
    theme(
      plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
      axis.title = element_text(size = 11, face = "bold", margin = margin(t = 10, r = 10, b = 10, l = 10)),
      axis.text = element_text(size = 10),
      plot.margin = margin(t = 20, r = 20, b = 20, l = 20)
    ) +
    scale_x_continuous(labels = label_number(scale_cut = cut_short_scale())) +
    scale_y_continuous(labels = label_number(scale_cut = cut_short_scale())) +
    labs(
      title = paste("Correlation:", ifelse(is.na(corr_val), "NA", round(corr_val, 2))),
      x = kpi_univ,
      y = paste(variable_univ, "(Transformed)")
    )
  
  ggplotly(p) %>%
    layout(
      autosize = TRUE,
      margin = list(l = 80, r = 40, t = 60, b = 80)
    )
}
# Suggested_Max_Value_Univariate.R

# =============================================================================
# Displays some suggested maximum value percentages for s-curves or 
# general transformations.
# =============================================================================

render_transformations_summary <- function(df, input) {
  # Generates suggestions for transformation parameters
  #
  # Args:
  #   df: Dataframe with data
  #   input: Shiny input object with variable selection
  #
  # Returns:
  #   Text with parameter suggestions
  
  req(input$transformation_univ, df, input$variable_univ)
  validate(
    need(input$variable_univ != "N/A", "Please select a valid variable for the summary.")
  )

  box_data <- df[[input$variable_univ]]
  box_data <- box_data[!is.na(box_data)]

  if (length(box_data) == 0) {
    cat("Not enough data to calculate suggestions.\n")
    return()
  }

  data_mean <- mean(box_data, na.rm = TRUE)
  data_sd   <- sd(box_data,   na.rm = TRUE)
  box_max   <- max(box_data,  na.rm = TRUE)

  # Boxplot outlier-based approach
  q1 <- quantile(box_data, 0.25, na.rm = TRUE)
  q3 <- quantile(box_data, 0.75, na.rm = TRUE)
  iqr <- q3 - q1
  upper_limit <- q3 + 1.5 * iqr
  max_not_outlier <- ifelse(box_max > upper_limit, upper_limit, box_max)
  maxval_percent_boxplot <- (max_not_outlier / box_max) * 100

  # 3 standard deviations approach
  three_sd_value <- data_mean + 3 * data_sd
  maxval_percent_three_sd <- (three_sd_value / box_max) * 100

  # Average between mean and max
  avg_mean_max <- (data_mean + box_max) / 2
  maxval_percent_avg <- (avg_mean_max / box_max) * 100

  cat("Suggested %MaxVal:\n")
  cat("Based on boxplot (no-outlier cap):", round(maxval_percent_boxplot, 2), "%\n")
  cat("Three Standard Deviations:",       round(maxval_percent_three_sd, 2), "%\n")
  cat("Average of Mean and Maximum:",     round(maxval_percent_avg, 2), "%\n")
}# S_Curve_EDA_Univariate.R


source("R/modules/common/s_curve_charts.R")
source("R/modules/common/s_curve_helpers.R")
library(dplyr)
library(shiny)
library(plotly)
library(shinycssloaders)

# -------------------------------------------------------------------------
# render_s_curve_plots: Renders the Univariate S-Curve and Flighting charts
# -------------------------------------------------------------------------
render_s_curve_plots <- function(df, input) {
  req(df, input$variable_univ)
  validate(
    need(input$variable_univ != "N/A", "Please select a valid variable for the S-Curve."),
    need(input$transformation_univ %in% c("S Origin", "S Shaped"), "This chart is only displayed for 'S Origin' or 'S Shaped'.")
  )
 
  # Use data already filtered by global filter
  df_scurve <- df %>%
    mutate(Period = if ("Period" %in% names(.)) as.Date(Period) else as.Date(periodo)) %>%
    select(Period, value = !!sym(input$variable_univ))
 
  # Apply lag and decay to data
  if (input$lag_univ > 0) {
    if (input$lag_univ >= nrow(df_scurve)) df_scurve$value <- rep(NA, nrow(df_scurve))
    else df_scurve$value <- c(rep(NA, input$lag_univ), head(df_scurve$value, -input$lag_univ))
  }
 
  df_scurve$value <- as.numeric(df_scurve$value) * input$decay_univ
 
  if (nrow(df_scurve) == 0) return(plot_ly() %>% layout(title = "No data available for S-Curve."))
 
  # Data for average calculation (green line)
  avg_data <- NULL
  avg_period <- 52  # Default value
  
  # Check if we have a date range selected for average calculation
  if (!is.null(input$avg_date_range_univ) && 
      length(input$avg_date_range_univ) == 2 && 
      !is.na(input$avg_date_range_univ[1]) && 
      !is.na(input$avg_date_range_univ[2])) {
      
    # Filter data for average calculation, excluding zeros
    avg_data <- df_scurve %>%
      filter(Period >= input$avg_date_range_univ[1] & 
             Period <= input$avg_date_range_univ[2] &
             value > 0)  # Exclude zeros
    
    # Only update avg_period if there's data in the range
    if (nrow(avg_data) > 0) {
      avg_period <- nrow(avg_data)
    } else {
      # If no data in range, clear avg_data to use the average of the whole series
      avg_data <- NULL
    }
  }
  
  # Verify we have data for average calculation
  if (is.null(avg_data)) {
    # Use all non-zero values if no specific data
    avg_period <- nrow(df_scurve %>% filter(value > 0))
  }
 
  # Create charts with appropriate variable values
  var_name    <- input$variable_univ
  alpha       <- input$alpha_univ
  beta        <- input$beta_univ
  max_val_pct <- input$maxval_univ
  decay       <- input$decay_univ
  lag         <- input$lag_univ
 
  # First generate Flighting Chart to get its configurations
  flighting_plot <- tryCatch({
    create_flighting_chart(
      data_chart = df_scurve,
      alpha = alpha,
      beta = beta,
      max_val_pct = max_val_pct,
      decay = decay,
      lag = lag,
      var_name = var_name,
      calculated_key_points = NULL,  # No key points yet
      avg_period = avg_period,
      avg_data = avg_data  # Pass filtered data for average calculation
    )
  }, error = function(e) {
    return(plot_ly() %>% layout(title = paste("Error in Flighting Chart:", e$message)))
  })
  
  # Then generate S-Curve using Flighting Chart configurations
  s_curve_plot <- tryCatch({
    create_s_curve_chart(
      data_chart = df_scurve,
      alpha = alpha,
      beta = beta,
      max_val_pct = max_val_pct,
      decay = decay,
      lag = lag,
      var_name = var_name,
      avg_period = avg_period,
      avg_data = avg_data,  # Pass filtered data for average calculation
      flighting_chart = flighting_plot  # Pass flighting chart to coordinate axes
    )
  }, error = function(e) {
    return(plot_ly() %>% layout(title = paste("Error in S-Curve Chart:", e$message)))
  })
  
  # Get key points from S-Curve
  key_points <- attr(s_curve_plot, "key_points")
  
  # Recreate Flighting Chart with S-Curve key points
  flighting_plot <- tryCatch({
    create_flighting_chart(
      data_chart = df_scurve,
      alpha = alpha,
      beta = beta,
      max_val_pct = max_val_pct,
      decay = decay,
      lag = lag,
      var_name = var_name,
      calculated_key_points = key_points,  # Use key points from S-Curve
      avg_period = avg_period,
      avg_data = avg_data  # Pass filtered data for average calculation
    )
  }, error = function(e) {
    return(plot_ly() %>% layout(title = paste("Error in Flighting Chart:", e$message)))
  })
 
  # Create combined subplot
  subplot(flighting_plot, s_curve_plot, nrows = 1, widths = c(0.7, 0.3), titleX = TRUE, titleY = TRUE, margin = 0.05) %>%
    layout(
      title = "",
      margin = list(l = 60, r = 60, b = 60, t = 10, pad = 10),
      autosize = TRUE,
      plot_bgcolor = '#FFFFFF',
      paper_bgcolor = '#FFFFFF',
      font = list(family = "Arial, sans-serif"),
      hoverlabel = list(bgcolor = "#FFF", font = list(size = 12, family = "Arial, sans-serif"), bordercolor = "#DDD")
    ) %>%
    config(displayModeBar = TRUE, displaylogo = FALSE, modeBarButtonsToRemove = list('sendDataToCloud', 'hoverCompareCartesian', 'hoverClosestCartesian', 'select2d', 'lasso2d'), responsive = TRUE)
}

# -------------------------------------------------------------------------
# ui_s_curve_eda_univariate: UI for the S-Curve EDA module (Univariate)
# -------------------------------------------------------------------------
ui_s_curve_eda_univariate <- function(id) {
  ns <- NS(id)
 
  fluidPage(
    fluidRow(
      column(3,
             wellPanel(
               style = "background-color: #f9f9f9; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.1);",
               h4("Parameters", style = "font-weight: bold; color: #333; border-bottom: 1px solid #ddd; padding-bottom: 8px;"),
               selectInput(ns("variable_univ"), "Variable:", choices = c("Select" = "N/A"), width = "100%"),
               selectInput(ns("transformation_univ"), "Transformation:",
                           choices = c("Linear", "S Origin", "S Shaped", "Index Exp", "Log", "Exp", "Power", "Moving Avg"),
                           selected = "S Origin", width = "100%"),
               sliderInput(ns("alpha_univ"), "Alpha:", min = 0.01, max = 0.99, value = 0.85, step = 0.01, width = "100%"),
               sliderInput(ns("beta_univ"), "Beta:", min = 0.01, max = 10, value = 1, step = 0.01, width = "100%"),
               sliderInput(ns("maxval_univ"), "Max Value %:", min = 50, max = 200, value = 100, step = 5, width = "100%"),
               sliderInput(ns("decay_univ"), "Decay:", min = 0.01, max = 5, value = 1, step = 0.01, width = "100%"),
               numericInput(ns("lag_univ"), "Lag (periods):", min = 0, max = 100, value = 0, step = 1, width = "100%"),
               
               # Selector for average period
               conditionalPanel(
                 condition = paste0("input['", ns("transformation_univ"), "'] == 'S Origin' || input['", ns("transformation_univ"), "'] == 'S Shaped'"),
                 div(style = "margin-top: 15px;",
                     h4("Average Period Selection", style = "font-weight: bold; color: #333; border-bottom: 1px solid #ddd; padding-bottom: 8px;"),
                     dateRangeInput(ns("avg_date_range_univ"), "Select Date Range for Average:",
                                    start = Sys.Date() - 365,
                                    end = Sys.Date(),
                                    separator = " to "),
                     helpText("This range ONLY affects the average calculation (green line)"),
                     # Specific button to update average
                     actionButton(ns("update_avg_univ"), "Update Average", 
                                 class = "btn-primary btn-block", 
                                 style = "margin-top: 10px;")
                 )
               )
             )
      ),
      column(9,
             div(
               class = "chart-box",
               style = "background-color: white; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); padding: 15px;",
               plotlyOutput(ns("s_curve_plot"), height = "600px") %>% withSpinner(color = "#0275d8", type = 5)
             )
      )
    )
  )
}

# -------------------------------------------------------------------------
# server_s_curve_eda_univariate: Server for the S-Curve EDA module (Univariate)
# -------------------------------------------------------------------------
server_s_curve_eda_univariate <- function(id, df, var_choices) {
  moduleServer(id, function(input, output, session) {
    observe({
      req(var_choices())
      updateSelectInput(session, "variable_univ", choices = c("Select" = "N/A", var_choices()))
    })
   
    # Initialize date values when data changes
    observe({
      req(df())
      # Detect date column
      date_col <- if ("Period" %in% names(df())) "Period" else if ("periodo" %in% names(df())) "periodo" else NULL
      if (!is.null(date_col)) {
        date_values <- as.Date(df()[[date_col]])
        date_values <- date_values[!is.na(date_values)]
        if (length(date_values) > 0) {
          min_date <- min(date_values, na.rm = TRUE)
          max_date <- max(date_values, na.rm = TRUE)
         
          # Update date range input for average
          updateDateRangeInput(session, "avg_date_range_univ",
                               start = min_date,
                               end = max_date)
        }
      }
    })
   
    # Filter data based on date range if exists
    filtered_data <- reactive({
      req(df())
      data <- df()
     
      # Convert date column if exists
      if ("Period" %in% names(data)) {
        data$Period <- as.Date(data$Period)
      } else if ("periodo" %in% names(data)) {
        data$Period <- as.Date(data$periodo)
      }
     
      return(data)
    })
    
    # Reactive value to force chart update
    update_trigger <- reactiveVal(0)
    
    # Specific observer for update button
    observeEvent(input$update_avg_univ, {
      update_trigger(update_trigger() + 1)
    }, ignoreInit = TRUE)
    
    # Observer for changes in parameters that affect the chart
    observe({
      # List of inputs that should trigger an update
      input$variable_univ
      input$transformation_univ
      input$alpha_univ
      input$beta_univ
      input$maxval_univ
      input$decay_univ
      input$lag_univ
      update_trigger() # Include update trigger
      
      # Update chart only if we have data and a selected variable
      if (!is.null(filtered_data()) && input$variable_univ != "N/A") {
        # Render chart
        output$s_curve_plot <- renderPlotly({
          render_s_curve_plots(filtered_data(), input)
        })
      }
    })
    
    # Render initial chart
    output$s_curve_plot <- renderPlotly({
      req(filtered_data(), input$variable_univ != "N/A")
      render_s_curve_plots(filtered_data(), input)
    })
  })
}# Transformed_Variable.R

# =============================================================================
# Renders the chart of the transformed variable over time.
# =============================================================================

render_transformation_chart <- function(df, variable_univ, transformation_univ,
                                        lag_univ, decay_univ,
                                        alpha_univ, beta_univ, maxval_univ,
                                        geography_univ) {
  # Generates a chart of the transformed variable
  #
  # Args:
  #   df: Dataframe with data
  #   variable_univ: Name of the variable to transform
  #   transformation_univ, lag_univ, decay_univ, alpha_univ, beta_univ, maxval_univ:
  #     Transformation parameters
  #   geography_univ: Selected geography (for title)
  #
  # Returns:
  #   plotly object with transformed variable chart
  
  req(df, variable_univ, transformation_univ)
  validate(
    need(variable_univ != "N/A", "Please select a valid variable for transformation.")
  )

  var_name <- variable_univ
  data_vec <- df[[var_name]]
  validate(
    need(length(data_vec) > 0, "No data available for transformation.")
  )

  data_trans <- as.numeric(data_vec)
  if (lag_univ > 0) {
    if (lag_univ >= length(data_trans)) {
      data_trans <- rep(NA, length(data_trans))
    } else {
      data_trans <- c(rep(NA, lag_univ), head(data_trans, -lag_univ))
    }
  }
  data_trans <- data_trans * decay_univ

  transformed_data <- tryCatch({
    switch(transformation_univ,
           "Linear"   = data_trans,
           "S Origin" = s_curve_transform(data_trans, "s-origin", alpha_univ, beta_univ, maxval_univ),
           "S Shaped" = s_curve_transform(data_trans, "s-shaped", alpha_univ, beta_univ, maxval_univ),
           "Index Exp"= 1 - exp(-(alpha_univ / 10) * data_trans),
           "Log"      = log1p(data_trans),
           "Exp"      = exp(data_trans),
           "Power"    = data_trans^alpha_univ,
           "Moving Avg" = {
             if (length(data_trans) < 3) rep(NA, length(data_trans))
             else zoo::rollmean(data_trans, k = 3, fill = NA, align = "right")
           },
           data_trans
    )
  }, error = function(e) {
    notifyUser(paste("Transformation error:", e$message), "error")
    data_trans
  })

  if (length(transformed_data) != nrow(df)) {
    notifyUser("Error: discrepancy between transformed data length and # rows.", "error")
    return(NULL)
  }

  date_col <- if ("Period" %in% names(df)) "Period" else "periodo"
  req(date_col)

  # # Create dataframe with transformed data
  # df_trans <- df %>%
  #   mutate(Transformed = transformed_data)
  # 
  # # Apply quarterly logic as in sum_variables_chart
  # df_trans <- df_trans %>%
  #   mutate(
  #     year = format(as.Date(.data[[date_col]]), "%Y"),
  #     quarter = lubridate::quarter(as.Date(.data[[date_col]])),
  #     month_label = case_when(
  #       quarter == 1 ~ "01",
  #       quarter == 2 ~ "04",
  #       quarter == 3 ~ "07",
  #       quarter == 4 ~ "10"
  #     ),
  #     label = paste0(year, "-", month_label)
  #   ) %>%
  #   group_by(label) %>%
  #   summarise(Transformed = mean(Transformed, na.rm = TRUE), .groups = "drop")
  # 
  # # Use plotly directly instead of converting from ggplot
  # p <- plot_ly(
  #   df_trans, 
  #   x = ~label, 
  #   y = ~Transformed, 
  #   type = 'scatter', 
  #   mode = 'lines+markers', 
  #   line = list(color = 'red')
  # ) %>%
  #   layout(
  #     title = paste("Transformed Variable (Geography:", geography_univ, ")"),
  #     xaxis = list(
  #       title = list(
  #         text = "Time",
  #         standoff = 25  # Increase space between title and axis
  #       ),
  #       type = "category", 
  #       tickangle = -45,
  #       automargin = TRUE
  #     ),
  #     yaxis = list(
  #       title = list(
  #         text = "Transformed Value",
  #         standoff = 20  # Increase space between title and axis
  #       ),
  #       automargin = TRUE
  #     ),
  #     margin = list(l = 70, r = 40, t = 60, b = 80),  # Increased margins
  #     showlegend = FALSE
  #   )
  # 
  # return(p)
  # Create dataframe with transformed data
  df_trans <- df %>%
    mutate(
      date = as.Date(.data[[date_col]]),
      Transformed = transformed_data
    ) %>%
    arrange(date)
  
  # Use plotly directly with real date and quarterly labels
  p <- plot_ly(
    df_trans, 
    x = ~date, 
    y = ~Transformed, 
    type = 'scatter', 
    mode = 'lines+markers', 
    line = list(color = 'red'),
    hovertemplate = paste(
      "Date: %{x|%Y-%m-%d}<br>",
      "Transformed: %{y:,.2f}<extra></extra>"
    )
  ) %>%
    layout(
      title = paste("Transformed Variable (Geography:", geography_univ, ")"),
      xaxis = list(
        title = list(text = "Time", standoff = 25),
        type = "date",
        tickformat = "%Y-%m",
        dtick = "M3",
        tickangle = -45,
        automargin = TRUE
      ),
      yaxis = list(
        title = list(text = "Transformed Value", standoff = 20),
        automargin = TRUE
      ),
      margin = list(l = 70, r = 40, t = 60, b = 80),
      showlegend = FALSE
    )
  
  return(p)
  
}# Univariate_Server.R

# =============================================================================
# Manages the univariate panel logic.
# =============================================================================

# -- AUXILIARY MODULES (load them here) --
source("R/modules/univariate/Boxplot.R", )
source("R/modules/univariate/Data_Filtering.R", )
source("R/modules/univariate/KPI_Variable_Correlation.R", )
source("R/modules/univariate/S_Curve_EDA.R", )
source("R/modules/univariate/Suggested_Max_Value.R", )
source("R/modules/univariate/Transformed_Variable.R", )
source("R/modules/univariate/Variable_Flighting.R", )

univariate_module_server <- function(input, output, session, rv) {
  # Server module for univariate analysis
  #
  # Args:
  #   input: Shiny input object
  #   output: Shiny output object
  #   session: Shiny session object
  #   rv: Shared reactive values
  
  # 1. Filter geography using *globally date-filtered data*
  #    (rv$filtered_data), not raw data rv$data:
  filtered_geography_data <- reactive({
    filter_geography_data(rv$filtered_data, input$geography_univ)
  })
  
  # 2. Render main charts
  output$variable_flighting_chart <- renderPlotly({
    req(filtered_geography_data(), input$kpi_univ, input$variable_univ)
    validate(
      need(input$variable_univ != "N/A", "Please select a valid variable for analysis.")
    )
    render_variable_flighting(
      filtered_geography_data(),
      input$kpi_univ,
      input$variable_univ,
      input$geography_univ
    )
  })
  
  output$var_transf_chart <- renderPlotly({
    req(filtered_geography_data(), input$variable_univ, input$transformation_univ)
    validate(
      need(input$variable_univ != "N/A", "Please select a valid variable for transformation.")
    )
    render_transformation_chart(
      filtered_geography_data(),
      input$variable_univ,
      input$transformation_univ,
      input$lag_univ,
      input$decay_univ,
      input$alpha_univ,
      input$beta_univ,
      input$maxval_univ,
      input$geography_univ
    )
  })
  
  output$boxplot_univ <- renderPlot({
    req(filtered_geography_data(), input$variable_univ)
    validate(
      need(input$variable_univ != "N/A", "Please select a valid variable for the boxplot.")
    )
    render_boxplot_univariate(
      filtered_geography_data(),
      input$variable_univ,
      input$geography_univ
    )
  })
  
  output$transformations_summary_univ <- renderPrint({
    req(input$transformation_univ, filtered_geography_data(), input$variable_univ)
    validate(
      need(input$variable_univ != "N/A", "Please select a valid variable for the summary.")
    )
    render_transformations_summary(filtered_geography_data(), input)
  })
  
  output$s_curve_univariate_plot <- renderPlotly({
    req(filtered_geography_data(), input$variable_univ)
    validate(
      need(input$variable_univ != "N/A", "Please select a valid variable for the S-Curve."),
      need(
        input$transformation_univ %in% c("S Origin", "S Shaped"),
        "This chart is only shown for 'S Origin' or 'S Shaped'."
      )
    )
    render_s_curve_plots(filtered_geography_data(), input)
  })
  
  output$corr_kpi_var_univ <- renderPlotly({
    req(filtered_geography_data(), input$kpi_univ, input$variable_univ, input$transformation_univ)
    validate(
      need(input$variable_univ != "N/A", "Please select a valid variable to calculate correlation.")
    )
    render_correlation_plot(
      df = filtered_geography_data(),
      kpi_univ = input$kpi_univ,
      variable_univ = input$variable_univ,
      transformation_univ = input$transformation_univ,
      lag_univ = input$lag_univ,
      decay_univ = input$decay_univ,
      alpha_univ = input$alpha_univ,
      beta_univ = input$beta_univ,
      maxval_univ = input$maxval_univ
    )
  })
}# Variable_Flighting.R

# =============================================================================
# Renders a flighting chart comparing KPI and the selected variable.
# =============================================================================

render_variable_flighting <- function(df, kpi_univ, variable_univ, geography_univ) {
  # Generates a chart comparing KPI and selected variable
  #
  # Args:
  #   df: Dataframe with data
  #   kpi_univ: Name of the KPI variable
  #   variable_univ: Name of the variable to compare
  #   geography_univ: Selected geography (for title)
  #
  # Returns:
  #   plotly object with comparison chart
  
  req(df, kpi_univ, variable_univ)
  validate(
    need(variable_univ != "N/A", "Please select a valid variable for analysis.")
  )

  date_col <- if ("Period" %in% names(df)) "Period" else "periodo"
  req(date_col)

  data_to_plot <- df %>%
    select(!!sym(date_col), KPI = !!sym(kpi_univ), Variable = !!sym(variable_univ))

  validate(
    need(nrow(data_to_plot) > 0, "No data available for plotting.")
  )

  # # Apply quarterly logic as in sum_variables_chart
  # data_to_plot <- data_to_plot %>%
  #   mutate(
  #     year = format(as.Date(get(date_col)), "%Y"),
  #     quarter = lubridate::quarter(as.Date(get(date_col))),
  #     month_label = case_when(
  #       quarter == 1 ~ "01",
  #       quarter == 2 ~ "04",
  #       quarter == 3 ~ "07",
  #       quarter == 4 ~ "10"
  #     ),
  #     label = paste0(year, "-", month_label)
  #   ) #%>%
  #   # group_by(label) %>%
  #   # summarise(
  #   #   KPI = mean(KPI, na.rm = TRUE),
  #   #   Variable = mean(Variable, na.rm = TRUE),
  #   #   .groups = "drop"
  #   # )
  # 
  # # Build the chart using label as x-axis
  # p <- plot_ly(data_to_plot, x = ~label) %>%
  #   add_lines(
  #     y = ~KPI, 
  #     name = "KPI", 
  #     line = list(color = "blue"), 
  #     mode = "lines+markers"
  #   ) %>%
  #   add_lines(
  #     y = ~Variable, 
  #     name = "Variable", 
  #     yaxis = "y2", 
  #     line = list(color = "red"), 
  #     mode = "lines+markers"
  #   ) %>%
  #   layout(
  #     title = paste("KPI vs. Variable (Geography:", geography_univ, ")"),
  #     xaxis = list(
  #       title = list(
  #         text = "Time",
  #         standoff = 25
  #       ), 
  #       type = "category", 
  #       tickangle = -45,
  #       automargin = TRUE
  #     ),
  #     yaxis = list(
  #       title = list(
  #         text = "KPI",
  #         standoff = 20
  #       ), 
  #       side = "left",
  #       automargin = TRUE
  #     ),
  #     yaxis2 = list(
  #       title = list(
  #         text = "Variable",
  #         standoff = 20
  #       ), 
  #       overlaying = "y", 
  #       side = "right",
  #       automargin = TRUE
  #     ),
  #     legend = list(
  #       orientation = "v",   # vertical orientation
  #       xanchor = "left",
  #       x = 1.02,            # push to the right of the plot
  #       y = 1,
  #       bgcolor = "rgba(255,255,255,0.95)"  # optional: background for better visibility
  #     ),
  #     margin = list(l = 70, r = 120, t = 60, b = 80),  # increased right margin
  #     hovermode = "x unified"
  #   )
  # return(p)
  
  data_to_plot <- data_to_plot %>%
    mutate(
      date = as.Date(get(date_col)),
      year = format(date, "%Y"),
      quarter = lubridate::quarter(date),
      month_label = case_when(
        quarter == 1 ~ "01",
        quarter == 2 ~ "04",
        quarter == 3 ~ "07",
        quarter == 4 ~ "10"
      ),
      label = paste0(year, "-", month_label)
    )
  
  # Ordenar por fecha
  data_to_plot <- data_to_plot %>% arrange(date)
  
  # Crear gráfico en plotly
  # p <- plot_ly(data_to_plot, x = ~date) %>%
  #   add_lines(
  #     y = ~KPI, 
  #     name = "KPI", 
  #     line = list(color = "blue"), 
  #     mode = "lines+markers"
  #   ) %>%
  #   add_lines(
  #     y = ~Variable, 
  #     name = "Variable", 
  #     yaxis = "y2", 
  #     line = list(color = "red"), 
  #     mode = "lines+markers"
  #   ) %>%
  #   layout(
  #     title = paste("KPI vs. Variable (Geography:", geography_univ, ")"),
  #     xaxis = list(
  #       title = list(text = "Time", standoff = 25),
  #       type = "date",
  #       tickformat = "%Y-%m",  # Formato año-mes
  #       tickangle = -45,
  #       dtick = "M3",          # Cada 3 meses
  #       automargin = TRUE
  #     ),
  #     yaxis = list(
  #       title = list(text = "KPI", standoff = 20),
  #       side = "left",
  #       automargin = TRUE
  #     ),
  #     yaxis2 = list(
  #       title = list(text = "Variable", standoff = 20),
  #       overlaying = "y", 
  #       side = "right",
  #       automargin = TRUE
  #     ),
  #     legend = list(
  #       orientation = "v",
  #       xanchor = "left",
  #       x = 1.02,
  #       y = 1,
  #       bgcolor = "rgba(255,255,255,0.95)"
  #     ),
  #     margin = list(l = 70, r = 120, t = 60, b = 80),
  #     hovermode = "x unified"
  #   )
  # 
  # return(p)
  p <- plot_ly(data_to_plot, x = ~date) %>%
    add_lines(
      y = ~KPI, 
      name = "KPI", 
      line = list(color = "blue"), 
      mode = "lines+markers",
      hovertemplate = paste(
        "Date: %{x|%Y-%m-%d}<br>",
        "KPI: %{y:.2f}<extra></extra>"
      )
    ) %>%
    add_lines(
      y = ~Variable, 
      name = "Variable", 
      yaxis = "y2", 
      line = list(color = "red"), 
      mode = "lines+markers",
      hovertemplate = paste(
        "Date: %{x|%Y-%m-%d}<br>",
        "Variable: %{y:.2f}<extra></extra>"
      )
    ) %>%
    layout(
      title = paste("KPI vs. Variable (Geography:", geography_univ, ")"),
      xaxis = list(
        title = list(text = "Time", standoff = 25),
        type = "date",
        tickformat = "%Y-%m",
        dtick = "M3",
        tickangle = -45,
        automargin = TRUE
      ),
      yaxis = list(
        title = list(text = "KPI", standoff = 20),
        side = "left",
        automargin = TRUE
      ),
      yaxis2 = list(
        title = list(text = "Variable", standoff = 20),
        overlaying = "y", 
        side = "right",
        automargin = TRUE
      ),
      legend = list(
        orientation = "v",
        xanchor = "left",
        x = 1.02,
        y = 1,
        bgcolor = "rgba(255,255,255,0.95)"
      ),
      margin = list(l = 70, r = 120, t = 60, b = 80),
      hovermode = "x unified"
    )
  return(p)
  
}# R/server.R
# =============================================================================
# Main server logic.
# Integrates data loading, initial global filters, date filtering,
# dynamic compound filters for Univariate and Multivariate panels,
# module calls and download handling.
# =============================================================================

suppressPackageStartupMessages({
  library(shiny)
  library(dplyr)
  library(tidyr)
  library(ggplot2)
  library(corrplot)
  library(zoo)
  library(stringr)
  library(DT)
  library(plotly)
  library(purrr)
  library(gridExtra)
  library(scales) # Make sure this is on the list (from v2)
  library(RColorBrewer) # Make sure this is on the list (from v2)
})

# --- Load common modules ---
source("R/Modules/Common/Global_Filters.R", local = TRUE)
source("R/modules/common/download_handler.R", local = TRUE)
source("R/modules/common/download_transformed_handlers.R", local = TRUE) # From v2

# --- Load information modules ---
source("R/modules/information/data_loader.R", local = TRUE)
source("R/modules/information/date_filter.R", local = TRUE)
source("R/modules/information/dimensions_ui.R", local = TRUE)
source("R/modules/information/data_summary.R", local = TRUE)
source("R/modules/information/file_info.R", local = TRUE)

# --- Load Univariate modules ---
# We use the v2 file name if it’s different
source("R/modules/univariate/Univariate_Server.R", local = TRUE) # v2 name

# --- Load Multivariate modules ---
# We use the v2 file name if it’s different
source("R/modules/multivariate/Multivariate_Server.R", local = TRUE) # v2 name

# Notification function (if not globally defined, add or replace it)
# If 'notifyUser' is your custom function, make sure it’s available.
# If not, you can replace it with Shiny’s showNotification.
# Example replacement: notifyUser <- function(msg, type = "message", ...) { showNotification(msg, type = type, ...) }
# For now, we'll assume notifyUser exists.

server <- function(input, output, session) {
  # --- Global reactive values ---
  rv <- reactiveValues(
    data          = NULL, # Original loaded data
    filtered_data = NULL, # Data filtered ONLY by date
    date_col      = NULL  # Name of the detected date column
    # rv$filtered_data_multi will be defined as a reactive further below
  )
  
  # --- 1. Data loading (v2 logic) ---
  observeEvent(input$file, {
    # notifyUser("A file has been selected for upload.", "message") # Optional: keep or replace with showNotification
    data <- load_data(input$file)
    if (!is.null(data)) {
      # Try to detect date column
      date_col <- names(data)[tolower(names(data)) %in% c("period", "periodo")][1]
      if (!is.na(date_col)) {
        tryCatch(
          {
            data[[date_col]] <- as.Date(data[[date_col]])
            rv$date_col <- date_col
            # Set initial date range in the input
            updateDateRangeInput(session, "date_range_filter",
                                 start = min(data[[date_col]], na.rm = TRUE),
                                 end   = max(data[[date_col]], na.rm = TRUE)
            )
            showNotification(paste("Date column detected:", date_col), type = "message")
          },
          error = function(e) {
            showNotification(paste("Error converting column", date_col, "to Date:", e$message), type = "error")
            rv$date_col <- NULL # Reset if conversion fails
          }
        )
      } else {
        showNotification("Warning: Could not detect a date column named 'Period' or 'periodo'. Date filter will not work.", type = "warning", duration = 10)
        rv$date_col <- NULL
      }
      
      rv$data <- data
      rv$filtered_data <- data # Initially, date-filtered data is the full dataset
      showNotification("Data loaded successfully.", type = "message")
    } else {
      showNotification("Error loading data from the file.", type = "error")
      # Reset values if loading fails
      rv$data <- NULL
      rv$filtered_data <- NULL
      rv$date_col <- NULL
    }
  })
  
  # --- 2. Initial update of global filters (v2 logic) ---
  # Runs once when rv$data changes (after file load)
  observe({
    req(rv$data)
    # This function (from global_filters.R) populates ALL selectInputs the first time
    update_global_filters(rv$data, input, session)
    # Note: This function ALREADY updates the initial choices for _univ and _multi
  })
  
  # --- 3. Date filtering (v2 logic) ---
  # This function updates rv$filtered_data when input$date_range_filter changes
  filter_data_by_date(input, rv) # Assumes this function uses rv$data and updates rv$filtered_data
  
  # --- 4. Dynamic filtering and SelectInput update for Univariate (logic restored from v1) ---
  
  # (a) Update of the "variable_univ" selectInput based on compound _univ filters
  observe({
    req(rv$data) # Needs the original data to see all possible metrics
    metric_info <- extract_metric_info(rv$data) # Uses the function from global_filters.R
    req(metric_info) # Ensure metric_info is not NULL
    
    # Filter available metrics based on _univ selections
    # Use %in% to support multiple selections if needed, and check != "N/A"
    if (!is.null(input$product_univ) && all(input$product_univ != "N/A")) {
      metric_info <- metric_info %>% filter(product %in% input$product_univ)
    }
    if (!is.null(input$campaign_univ) && all(input$campaign_univ != "N/A")) {
      metric_info <- metric_info %>% filter(campaign %in% input$campaign_univ)
    }
    if (!is.null(input$outlet_univ) && all(input$outlet_univ != "N/A")) {
      metric_info <- metric_info %>% filter(outlet %in% input$outlet_univ)
    }
    if (!is.null(input$creative_univ) && all(input$creative_univ != "N/A")) {
      metric_info <- metric_info %>% filter(creative %in% input$creative_univ)
    }
    
    current_selection <- input$variable_univ
    choices <- if (nrow(metric_info) > 0) unique(metric_info$colname) else character(0)
    
    # Keep the selection if still valid, otherwise select the first option or none
    selected_choice <- if (!is.null(current_selection) && current_selection %in% choices) {
      current_selection
    } else if (length(choices) > 0) {
      choices[1] # Or use NULL to force a new selection
    } else {
      NULL # Or character(0) if you prefer
    }
    
    updateSelectInput(session, "variable_univ", choices = choices, selected = selected_choice)
  })
  
  # (b) Interdependent dynamic update of compound _univ filters
  observe({
    req(rv$data)
    info <- extract_metric_info(rv$data)
    req(info)
    
    # Save current selections to restore them if still valid
    current_product <- input$product_univ
    current_campaign <- input$campaign_univ
    current_outlet <- input$outlet_univ
    current_creative <- input$creative_univ
    
    # Compute choices for Product (considering Campaign, Outlet, Creative)
    info_for_product <- info
    if (!is.null(current_campaign) && all(current_campaign != "N/A")) info_for_product <- filter(info_for_product, campaign %in% current_campaign)
    if (!is.null(current_outlet) && all(current_outlet != "N/A")) info_for_product <- filter(info_for_product, outlet %in% current_outlet)
    if (!is.null(current_creative) && all(current_creative != "N/A")) info_for_product <- filter(info_for_product, creative %in% current_creative)
    product_choices <- c("N/A", sort(unique(na.omit(info_for_product$product))))
    
    # Compute choices for Campaign (considering Product, Outlet, Creative)
    info_for_campaign <- info
    if (!is.null(current_product) && all(current_product != "N/A")) info_for_campaign <- filter(info_for_campaign, product %in% current_product)
    if (!is.null(current_outlet) && all(current_outlet != "N/A")) info_for_campaign <- filter(info_for_campaign, outlet %in% current_outlet)
    if (!is.null(current_creative) && all(current_creative != "N/A")) info_for_campaign <- filter(info_for_campaign, creative %in% current_creative)
    campaign_choices <- c("N/A", sort(unique(na.omit(info_for_campaign$campaign))))
    
    # Compute choices for Outlet (considering Product, Campaign, Creative)
    info_for_outlet <- info
    if (!is.null(current_product) && all(current_product != "N/A")) info_for_outlet <- filter(info_for_outlet, product %in% current_product)
    if (!is.null(current_campaign) && all(current_campaign != "N/A")) info_for_outlet <- filter(info_for_outlet, campaign %in% current_campaign)
    if (!is.null(current_creative) && all(current_creative != "N/A")) info_for_outlet <- filter(info_for_outlet, creative %in% current_creative)
    outlet_choices <- c("N/A", sort(unique(na.omit(info_for_outlet$outlet))))
    
    # Compute choices for Creative (considering Product, Campaign, Outlet)
    info_for_creative <- info
    if (!is.null(current_product) && all(current_product != "N/A")) info_for_creative <- filter(info_for_creative, product %in% current_product)
    if (!is.null(current_campaign) && all(current_campaign != "N/A")) info_for_creative <- filter(info_for_creative, campaign %in% current_campaign)
    if (!is.null(current_outlet) && all(current_outlet != "N/A")) info_for_creative <- filter(info_for_creative, outlet %in% current_outlet)
    creative_choices <- c("N/A", sort(unique(na.omit(info_for_creative$creative))))
    
    # Update SelectInputs, keeping the current selection if valid, otherwise default to 'N/A'
    updateSelectInput(session, "product_univ",
                      choices = product_choices,
                      selected = if (!is.null(current_product) && all(current_product %in% product_choices)) current_product else "N/A"
    )
    updateSelectInput(session, "campaign_univ",
                      choices = campaign_choices,
                      selected = if (!is.null(current_campaign) && all(current_campaign %in% campaign_choices)) current_campaign else "N/A"
    )
    updateSelectInput(session, "outlet_univ",
                      choices = outlet_choices,
                      selected = if (!is.null(current_outlet) && all(current_outlet %in% outlet_choices)) current_outlet else "N/A"
    )
    updateSelectInput(session, "creative_univ",
                      choices = creative_choices,
                      selected = if (!is.null(current_creative) && all(current_creative %in% creative_choices)) current_creative else "N/A"
    )
  })
  
  # --- 5. Dynamic filtering and SelectInput update for Multivariate (logic restored from v1) ---
  
  # (a) Interdependent dynamic update of compound _multi filters
  observe({
    req(rv$data)
    info <- extract_metric_info(rv$data)
    req(info)
    
    # Save current selections
    current_product_multi <- input$product_multi
    current_campaign_multi <- input$campaign_multi
    current_outlet_multi <- input$outlet_multi
    current_creative_multi <- input$creative_multi
    
    # Compute options for Product (considering Campaign, Outlet, Creative _multi)
    info_product_multi <- info
    if (!is.null(current_campaign_multi) && all(current_campaign_multi != "N/A")) info_product_multi <- filter(info_product_multi, campaign %in% current_campaign_multi)
    if (!is.null(current_outlet_multi) && all(current_outlet_multi != "N/A")) info_product_multi <- filter(info_product_multi, outlet %in% current_outlet_multi)
    if (!is.null(current_creative_multi) && all(current_creative_multi != "N/A")) info_product_multi <- filter(info_product_multi, creative %in% current_creative_multi)
    product_choices_multi <- c("N/A", sort(unique(na.omit(info_product_multi$product))))
    
    # Compute options for Campaign (considering Product, Outlet, Creative _multi)
    info_campaign_multi <- info
    if (!is.null(current_product_multi) && all(current_product_multi != "N/A")) info_campaign_multi <- filter(info_campaign_multi, product %in% current_product_multi)
    if (!is.null(current_outlet_multi) && all(current_outlet_multi != "N/A")) info_campaign_multi <- filter(info_campaign_multi, outlet %in% current_outlet_multi)
    if (!is.null(current_creative_multi) && all(current_creative_multi != "N/A")) info_campaign_multi <- filter(info_campaign_multi, creative %in% current_creative_multi)
    campaign_choices_multi <- c("N/A", sort(unique(na.omit(info_campaign_multi$campaign))))
    
    # Compute options for Outlet (considering Product, Campaign, Creative _multi)
    info_outlet_multi <- info
    if (!is.null(current_product_multi) && all(current_product_multi != "N/A")) info_outlet_multi <- filter(info_outlet_multi, product %in% current_product_multi)
    if (!is.null(current_campaign_multi) && all(current_campaign_multi != "N/A")) info_outlet_multi <- filter(info_outlet_multi, campaign %in% current_campaign_multi)
    if (!is.null(current_creative_multi) && all(current_creative_multi != "N/A")) info_outlet_multi <- filter(info_outlet_multi, creative %in% current_creative_multi)
    outlet_choices_multi <- c("N/A", sort(unique(na.omit(info_outlet_multi$outlet))))
    
    # Compute options for Creative (considering Product, Campaign, Outlet _multi)
    info_creative_multi <- info
    if (!is.null(current_product_multi) && all(current_product_multi != "N/A")) info_creative_multi <- filter(info_creative_multi, product %in% current_product_multi)
    if (!is.null(current_campaign_multi) && all(current_campaign_multi != "N/A")) info_creative_multi <- filter(info_creative_multi, campaign %in% current_campaign_multi)
    if (!is.null(current_outlet_multi) && all(current_outlet_multi != "N/A")) info_creative_multi <- filter(info_creative_multi, outlet %in% current_outlet_multi)
    creative_choices_multi <- c("N/A", sort(unique(na.omit(info_creative_multi$creative))))
    
    # Update _multi SelectInputs
    updateSelectInput(session, "product_multi",
                      choices = product_choices_multi,
                      selected = if (!is.null(current_product_multi) && all(current_product_multi %in% product_choices_multi)) current_product_multi else "N/A"
    )
    updateSelectInput(session, "campaign_multi",
                      choices = campaign_choices_multi,
                      selected = if (!is.null(current_campaign_multi) && all(current_campaign_multi %in% campaign_choices_multi)) current_campaign_multi else "N/A"
    )
    updateSelectInput(session, "outlet_multi",
                      choices = outlet_choices_multi,
                      selected = if (!is.null(current_outlet_multi) && all(current_outlet_multi %in% outlet_choices_multi)) current_outlet_multi else "N/A"
    )
    updateSelectInput(session, "creative_multi",
                      choices = creative_choices_multi,
                      selected = if (!is.null(current_creative_multi) && all(current_creative_multi %in% creative_choices_multi)) current_creative_multi else "N/A"
    )
  })
  
  # (b) Dynamic update of VARIABLE SELECTION (var1_multi, etc.) for Multivariate
  observe({
    req(rv$data)
    metric_info <- extract_metric_info(rv$data)
    req(metric_info)
    
    # Filter metrics based on _multi selections
    if (!is.null(input$product_multi) && all(input$product_multi != "N/A")) {
      metric_info <- metric_info %>% filter(product %in% input$product_multi)
    }
    if (!is.null(input$campaign_multi) && all(input$campaign_multi != "N/A")) {
      metric_info <- metric_info %>% filter(campaign %in% input$campaign_multi)
    }
    if (!is.null(input$outlet_multi) && all(input$outlet_multi != "N/A")) {
      metric_info <- metric_info %>% filter(outlet %in% input$outlet_multi)
    }
    if (!is.null(input$creative_multi) && all(input$creative_multi != "N/A")) {
      metric_info <- metric_info %>% filter(creative %in% input$creative_multi)
    }
    
    # Get valid column names (metrics)
    choices <- if (nrow(metric_info) > 0) unique(metric_info$colname) else character(0)
    choices_with_none <- c("None", choices) # Add "None"
    
    # Helper function to update while preserving selection if valid
    update_multi_var_select <- function(inputId, current_selection) {
      selected_choice <- if (!is.null(current_selection) && current_selection %in% choices_with_none) {
        current_selection
      } else {
        "None" # Default to "None" if the current selection is no longer valid or is NULL
      }
      updateSelectInput(session, inputId, choices = choices_with_none, selected = selected_choice)
    }
    
    # Update variable selectors for the multivariate panel
    # Note: update_global_filters already initializes them with "None", here we refine
    update_multi_var_select("kpi_multi", input$kpi_multi)     # If you have kpi_multi
    update_multi_var_select("var1_multi", input$var1_multi)
    update_multi_var_select("var2_multi", input$var2_multi)
    update_multi_var_select("var3_multi", input$var3_multi)
    update_multi_var_select("var4_multi", input$var4_multi)
    # Add more varX_multi updates here if needed
  })
  
  # --- 6. Exclusive filtering for the Multivariate panel (Geography) (logic restored from v1) ---
  # A specific reactive rv$filtered_data_multi is created, which starts from the date-filtered data (rv$filtered_data)
  # and applies the geography filter input$geography_multi.
  rv$filtered_data_multi <- reactive({
    # Depends on date-filtered data and the geography_multi input
    req(rv$filtered_data, input$geography_multi, rv$date_col)
    
    df <- rv$filtered_data # Start with data already filtered by date
    
    # Detect geography column (as done in global_filters.R)
    geo_col <- NULL
    if ("Geography" %in% names(df)) {
      geo_col <- "Geography"
    } else if ("Geografia" %in% names(df)) geo_col <- "Geografia"
    
    # Apply geography filter
    if (!is.null(geo_col) && input$geography_multi != "Total" && input$geography_multi != "N/A") {
      # Filter by selected geography
      df <- df %>% filter(.data[[geo_col]] == input$geography_multi)
    } else if (is.null(geo_col) && input$geography_multi != "Total") {
      # If there's no geo column but something other than Total is selected, warn and return unfiltered df
      showNotification("Warning: No geography column found to filter in Multivariate.", type = "warning")
      # Return df as is (already filtered by date)
    } else if (input$geography_multi == "Total") {
      # If "Total" is selected, aggregate numerics grouped by date
      # Ensure the date column exists (already checked with req(rv$date_col))
      numeric_cols <- names(df)[sapply(df, is.numeric)]
      # Exclude columns that shouldn’t be summed if needed (e.g., numeric IDs)
      # numeric_cols <- setdiff(numeric_cols, c("id_column"))
      
      # Group only by the detected date column
      df <- df %>%
        group_by(across(all_of(rv$date_col))) %>%
        summarise(across(all_of(numeric_cols), ~ sum(.x, na.rm = TRUE)), .groups = "drop")
      
      # If there was a geography column, optionally add it with value "Total"
      # if (!is.null(geo_col)) df[[geo_col]] <- "Total" # Optional
    }
    # If it's "N/A" or something unexpected, simply return df (filtered by date)
    
    return(df)
  })
  
  
  # --- 7. Modules for the Information tab (logic from v2) ---
  dimensions_ui_module_server(input, output, session, rv)
  data_summary_module_server(input, output, session, rv)
  file_info_module_server(input, output, session, rv)
  
  # --- 8. Module calls: Univariate and Multivariate ---
  # The Univariate module uses rv$filtered_data and applies internal filters (geography_univ, variable_univ, etc.)
  univariate_module_server(input, output, session, rv)
  
  # The Multivariate module SHOULD use rv$filtered_data_multi()
  # We pass the whole 'rv', the module internally accesses rv$filtered_data_multi()
  multivariate_module_server(input, output, session, rv)
  
  # --- 9. Download module for analytical data (existing - v2 logic) ---
  download_handler_module(input, output, session, rv) # General download
  
  # --- 10. New handlers for transformed data downloads (v2 logic) ---
  univariate_download_handler(input, output, session, rv)
  multivariate_download_handler(input, output, session, rv)
  
  # --- 11. Observer for animation classes in download buttons (v2 logic) ---
  observe({
    # Initialize or reset the class (e.g., when loading the app or switching tabs)
    ids <- c("download_univariate", "download_multivariate_sum", "download_multivariate_individual")
    for (id in ids) {
      session$sendCustomMessage(
        type = "toggleDownloadButtonClass",
        message = list(id = id, downloading = FALSE)
      )
    }
    # You may need additional logic here to control when animation is toggled
    # possibly using observers on the inputs that trigger computations.
  })
} # End of server function
# Information_UI.R

ui_information <- function() {
  tagList(
    fluidPage(
      tags$head(
        tags$link(rel = "stylesheet", type = "text/css", href = "styles.css")
      ),
      # Section: Data Management
      div(class = "section-card",
          h4("Data Management:", class = "section-title"),
          div(class = "upload-zone",
              fileInput("file", NULL,
                        accept = c(".csv", ".RData"),
                        buttonLabel = "Select File",
                        placeholder = "Drag and Drop files here"
              ),
              tags$small("Supported format: CSV, RData", 
                         style = "display: block; margin-top: 0.5rem; color: #6c757d;")
          ),
          div(style = "margin-top: 1rem;",
              dateRangeInput("date_range_filter", "Date Range:",
                             start  = Sys.Date() - 30,
                             end    = Sys.Date(),
                             format = "yyyy-mm-dd",
                             language = "en"
              )
          )
      ),
      
      # Section: Variable Configuration
      div(class = "section-card",
          h4("Variable Configuration", class = "section-title"),
          div(class = "variable-config-container",
              div(class = "variable-group",
                  div(class = "variable-group-title", "KPI"),
                  selectInput("kpi", NULL,
                              choices = NULL,
                              selectize = TRUE,
                              width = "100%")
              ),
              conditionalPanel(
                condition = "input.kpi",
                div(
                  div(class = "variable-group",
                      div(class = "variable-group-title", "Media Variables"),
                      selectInput("media_vars", NULL,
                                  choices = NULL,
                                  multiple = TRUE,
                                  selectize = TRUE,
                                  width = "100%")
                  ),
                  div(class = "variable-group",
                      div(class = "variable-group-title", "Spend Variables"),
                      selectInput("spend_vars", NULL,
                                  choices = NULL,
                                  multiple = TRUE,
                                  selectize = TRUE,
                                  width = "100%")
                  ),
                  div(class = "variable-group",
                      div(class = "variable-group-title", "Base Variables"),
                      selectInput("base_vars", NULL,
                                  choices = NULL,
                                  multiple = TRUE,
                                  selectize = TRUE,
                                  width = "100%")
                  )
                )
              )
          ),
          div(style = "margin-top: 1.5rem; text-align: right;",
              downloadButton("download_analytical", "Download Analytical File",
                             class = "custom-download-btn")
          )
      ),
      
      # Section: File Information
      div(class = "section-card",
          h4("File Information", class = "section-title"),
          div(class = "info-grid",
              div(class = "info-item",
                  div(class = "info-label", "Temporal Dimension"),
                  uiOutput("temporal_dimension_ui")
              ),
              div(class = "info-item",
                  div(class = "info-label", "Cross-Sectional Dimensions"),
                  uiOutput("cross_sectional_dimension_ui")
              )
          ),
          verbatimTextOutput("file_details")
      ),
      
      # Section: Summary Table
      div(class = "section-card",
          h4("Summary Table", class = "section-title"),
          div(class = "summary-table",
              withSpinner(
                DTOutput("consolidated_table"),
                type = 6,
                color = "#3498db",
                size = 1
              )
          ),
          div(style = "margin-top: 1rem; text-align: right;",
              downloadButton("download_consolidated", "Download Summary Table",
                             class = "custom-download-btn")
          )
      )
    )
  )
}
# # Multivariate_UI.R
# 
# # =============================================================================
# # Multivariate Analysis Tab
# # =============================================================================
# 
# ui_multivariate <- function() {
#   tagList(
#     fluidPage(
#       div(class = "section-card", h4("Global Filters", class = "section-title"),
#           fluidRow(
#             column(2, selectInput("geography_multi", "Geography", choices = NULL)),
#             column(2, selectInput("product_multi", "Product", choices = NULL)),
#             column(2, selectInput("campaign_multi", "Campaign", choices = NULL)),
#             column(2, selectInput("outlet_multi", "Outlet", choices = NULL)),
#             column(2, selectInput("creative_multi", "Creative", choices = NULL))            
#           )
#       ),
#       fluidRow(
#         column(width = 3,
#                div(class = "section-card",
#                    h4("Variable Selection", class = "section-title"),
#                    div(class = "pretty-radio", 
#                        prettyRadioButtons("sum_all_vars", "Add all variables",
#                                           choices = c("Yes" = "true", "No" = "false"), 
#                                           selected = "false", inline = TRUE, status = "primary")
#                    ),
#                    div(class = "variable-selection",
#                        selectInput("kpi_multi", "KPI", choices = c("None"), selected = "None"),
#                        selectInput("var1_multi", "Variable 1", choices = c("None"), selected = "None"),
#                        selectInput("var2_multi", "Variable 2", choices = c("None"), selected = "None"),
#                        selectInput("var3_multi", "Variable 3", choices = c("None"), selected = "None"),
#                        selectInput("var4_multi", "Variable 4", choices = c("None" = "None"), selected = "None")
#                    ),
#                    conditionalPanel(
#                      condition = "(input.trans_var1 == 'S Origin' || input.trans_var1 == 'S Shaped') && input.sum_all_vars == 'true'",
#                      div(style = "margin-top: 15px;",
#                          h4("Average Period Selection", class = "section-title"),
#                          dateRangeInput("avg_period_date_multi", "Select Date Range for Average:",
#                                         start = Sys.Date() - 365,
#                                         end = Sys.Date(),
#                                         separator = " to ")
#                      )
#                    ),
#                    conditionalPanel(
#                      condition = "input.sum_all_vars == 'true'",
#                      div(style = "margin-top: 15px; text-align: center;",
#                          downloadButton("download_multivariate_sum", "Download Summed Data", 
#                                         class = "btn-primary btn-block custom-download-btn",
#                                         icon = icon("download"))
#                      )
#                    ),
#                    conditionalPanel(
#                      condition = "input.sum_all_vars == 'false'",
#                      div(style = "margin-top: 15px; text-align: center;",
#                          downloadButton("download_multivariate_individual", "Download Individual Data", 
#                                         class = "btn-primary btn-block custom-download-btn",
#                                         icon = icon("download"))
#                      )
#                    )
#                ),
#                conditionalPanel(condition = "input.sum_all_vars == 'true'",
#                                 div(class = "section-card",
#                                     h4("Variable Transformation", class = "section-title"),
#                                     radioButtons(
#                                       inputId = "trans_var1", 
#                                       label = "Transf. Sum Data",
#                                       choices = c("Linear", "S Origin", "S Shaped", "Index Exp", "Log", "Exp", "Power", "Moving Avg"),
#                                       selected = "S Origin"
#                                     )
#                                 )
#                )
#         ),
#         column(width = 9,
#                conditionalPanel(condition = "input.sum_all_vars == 'true'",
#                                 div(class = "section-card",
#                                     h4("Transformation Settings", class = "section-title"),
#                                     div(class = "transform-params",
#                                         div(class = "transform-param-item", numericInput("decay_multi", "Decay", value = 1, min = 0, step = 0.1)),
#                                         div(class = "transform-param-item", numericInput("lag_multi", "Lag", value = 0, min = 0)),
#                                         div(class = "transform-param-item", numericInput("maxval_multi", "% MaxVal", value = 100, min = 0, step = 1)),
#                                         div(class = "transform-param-item", numericInput("alpha_multi", "Alpha", value = 0.85, min = 0, step = 0.01)),
#                                         div(class = "transform-param-item", numericInput("beta_multi", "Beta", value = 1, min = 0, step = 0.1))
#                                     )
#                                 ),
#                                 
#                                 conditionalPanel(
#                                   condition = "!(input.trans_var1 == 'S Origin' || input.trans_var1 == 'S Shaped')",
#                                   fluidRow(
#                                     column(6, div(class = "chart-box", h4("Summed Variables (Linear Flighting)", class = "chart-title"), plotlyOutput("sum_variables_chart", height = "320px"))),
#                                     column(6, div(class = "chart-box", h4("Transformed Summed Variables", class = "chart-title"), plotlyOutput("sum_variables_transf_chart", height = "320px")))
#                                   )
#                                 ),
#                                 
#                                 conditionalPanel(
#                                   condition = "input.trans_var1 == 'S Origin' || input.trans_var1 == 'S Shaped'",
#                                   div(class = "chart-box", h4("S-Curve EDA (Multivariate)", class = "chart-title"), plotlyOutput("s_curve_multivariate_plot", height = "100%"))
#                                 ),
#                                 
#                                 fluidRow(
#                                   column(6, div(class = "chart-box", h4("Boxplot (Summed Variable)", class = "chart-title"), plotlyOutput("boxplot_multi_sum", height = "300px"))),
#                                   column(6, div(class = "chart-box", h4("Suggested Max Value", class = "chart-title"), verbatimTextOutput("transformations_summary_multi", placeholder = TRUE)))
#                                 ),
#                                 fluidRow(
#                                   column(12, div(class = "chart-box", h4("Correlation with KPI", class = "chart-title"), plotlyOutput("corr_with_kpi_multi_sum", height = "300px")))
#                                 )
#                ),
#                conditionalPanel(condition = "input.sum_all_vars == 'false'",
#                                 fluidRow(
#                                   column(width = 12,
#                                          div(class = "chart-box", 
#                                              h4("Line Selected Variables", class = "chart-title"), 
#                                              plotlyOutput("boxplot_multi", height = "300px"))
#                                   )
#                                 ),
#                                 fluidRow(
#                                   column(width = 12,
#                                          div(class = "chart-box", 
#                                              h4("Correlation Matrix", class = "chart-title"), 
#                                              plotlyOutput("corr_matrix_multi", height = "300px"))
#                                   )
#                                 )
#                )
#         )
#       )
#     )
#   )
# }
# 

# Multivariate_UI.R

# =============================================================================
# Multivariate Analysis Tab
# =============================================================================

ui_multivariate <- function() {
  tagList(
    fluidPage(
      div(class = "section-card", h4("Global Filters", class = "section-title"),
          fluidRow(
            column(2, selectInput("geography_multi", "Geography", choices = NULL)),
            column(2, selectInput("product_multi", "Product", choices = NULL)),
            column(2, selectInput("campaign_multi", "Campaign", choices = NULL)),
            column(2, selectInput("outlet_multi", "Outlet", choices = NULL)),
            column(2, selectInput("creative_multi", "Creative", choices = NULL))            
          )
      ),
      fluidRow(
        column(width = 3,
               div(class = "section-card",
                   h4("Variable Selection", class = "section-title"),
                   div(class = "pretty-radio", 
                       prettyRadioButtons("sum_all_vars", "Add all variables",
                                          choices = c("Yes" = "true", "No" = "false"), 
                                          selected = "false", inline = TRUE, status = "primary")
                   ),
                   div(class = "variable-selection",
                       selectInput("kpi_multi", "KPI", choices = c("None"), selected = "None"),
                       selectInput("var1_multi", "Variable 1", choices = c("None"), selected = "None"),
                       selectInput("var2_multi", "Variable 2", choices = c("None"), selected = "None"),
                       selectInput("var3_multi", "Variable 3", choices = c("None"), selected = "None"),
                       selectInput("var4_multi", "Variable 4", choices = c("None" = "None"), selected = "None")
                   ),
                   conditionalPanel(
                     condition = "(input.trans_var1 == 'S Origin' || input.trans_var1 == 'S Shaped') && input.sum_all_vars == 'true'",
                     div(style = "margin-top: 15px;",
                         h4("Average Period Selection", class = "section-title"),
                         dateRangeInput("avg_period_date_multi", "Select Date Range for Average:",
                                        start = Sys.Date() - 365,
                                        end = Sys.Date(),
                                        separator = " to ")
                     )
                   ),
                   conditionalPanel(
                     condition = "input.sum_all_vars == 'true'",
                     div(style = "margin-top: 15px; text-align: center;",
                         downloadButton("download_multivariate_sum", "Download Summed Data", 
                                        class = "btn-primary btn-block custom-download-btn",
                                        icon = icon("download"))
                     )
                   ),
                   conditionalPanel(
                     condition = "input.sum_all_vars == 'false'",
                     div(style = "margin-top: 15px; text-align: center;",
                         downloadButton("download_multivariate_individual", "Download Individual Data", 
                                        class = "btn-primary btn-block custom-download-btn",
                                        icon = icon("download"))
                     )
                   )
               ),
               conditionalPanel(condition = "input.sum_all_vars == 'true'",
                                div(class = "section-card",
                                    h4("Variable Transformation", class = "section-title"),
                                    radioButtons(
                                      inputId = "trans_var1", 
                                      label = "Transf. Sum Data",
                                      choices = c("Linear", "S Origin", "S Shaped", "Index Exp", "Log", "Exp", "Power", "Moving Avg"),
                                      selected = "S Origin"
                                    )
                                )
               )
        ),
        column(width = 9,
               conditionalPanel(condition = "input.sum_all_vars == 'true'",
                                div(class = "section-card",
                                    h4("Transformation Settings", class = "section-title"),
                                    div(class = "transform-params",
                                        div(class = "transform-param-item", numericInput("decay_multi", "Decay", value = 1, min = 0, step = 0.1)),
                                        div(class = "transform-param-item", numericInput("lag_multi", "Lag", value = 0, min = 0)),
                                        div(class = "transform-param-item", numericInput("maxval_multi", "% MaxVal", value = 100, min = 0, step = 1)),
                                        div(class = "transform-param-item", numericInput("alpha_multi", "Alpha", value = 0.85, min = 0, step = 0.01)),
                                        div(class = "transform-param-item", numericInput("beta_multi", "Beta", value = 1, min = 0, step = 0.1))
                                    )
                                ),
                                
                                conditionalPanel(
                                  condition = "!(input.trans_var1 == 'S Origin' || input.trans_var1 == 'S Shaped')",
                                  fluidRow(
                                    column(6, div(class = "chart-box", h4("Summed Variables (Linear Flighting)", class = "chart-title"), plotlyOutput("sum_variables_chart", height = "320px"))),
                                    column(6, div(class = "chart-box", h4("Transformed Summed Variables", class = "chart-title"), plotlyOutput("sum_variables_transf_chart", height = "320px")))
                                  )
                                ),
                                
                                conditionalPanel(
                                  condition = "input.trans_var1 == 'S Origin' || input.trans_var1 == 'S Shaped'",
                                  div(class = "chart-box", h4("S-Curve EDA (Multivariate)", class = "chart-title"), plotlyOutput("s_curve_multivariate_plot", height = "100%"))
                                ),
                                
                                # ✅ Cambio aquí: los 3 gráficos en una sola fila
                                fluidRow(
                                  column(4, div(class = "chart-box", h4("Boxplot (Summed Variable)", class = "chart-title"), plotlyOutput("boxplot_multi_sum", height = "300px"))),
                                  column(4, div(class = "chart-box", h4("Suggested Max Value", class = "chart-title"), verbatimTextOutput("transformations_summary_multi", placeholder = TRUE))),
                                  column(4, div(class = "chart-box", h4("Correlation with KPI", class = "chart-title"), plotlyOutput("corr_with_kpi_multi_sum", height = "300px")))
                                )
               ),
               conditionalPanel(condition = "input.sum_all_vars == 'false'",
                                fluidRow(
                                  column(width = 12,
                                         div(class = "chart-box", 
                                             h4("Line Selected Variables", class = "chart-title"), 
                                             plotlyOutput("boxplot_multi", height = "300px"))
                                  )
                                ),
                                fluidRow(
                                  column(width = 12,
                                         div(class = "chart-box", 
                                             h4("Correlation Matrix", class = "chart-title"), 
                                             plotlyOutput("corr_matrix_multi", height = "300px"))
                                  )
                                )
               )
        )
      )
    )
  )
}
# Univariate_UI.R


# =============================================================================
# Univariate tan analysis
# =============================================================================

library(shiny)
library(shinycssloaders)

ui_univariate <- function() {
  tagList(
    fluidPage(
      div(class = "section-card", h4("Global Filters", class = "section-title"),
          fluidRow(
            column(2, selectInput("geography_univ", "Geography", choices = NULL)),
            column(2, selectInput("product_univ", "Product", choices = NULL)),
            column(2, selectInput("campaign_univ", "Campaign", choices = NULL)),
            column(2, selectInput("outlet_univ", "Outlet", choices = NULL)),
            column(2, selectInput("creative_univ", "Creative", choices = NULL))            
          )
      ),
      fluidRow(
        column(width = 3,
               div(class = "section-card",
                   h4("Variable Selection", class = "section-title"),
                   selectInput("kpi_univ", "KPI", choices = NULL),
                   selectInput("variable_univ", "Variable", choices = NULL),
                   h4("Transformation", class = "section-title"),
                   radioButtons("transformation_univ", NULL, choices = c("Linear", "S Origin", "S Shaped", "Index Exp", "Log", "Exp", "Power", "Moving Avg"), selected = "Linear"),
                   
                   # Date range for average of the Scurve
                   conditionalPanel(
                     condition = "input.transformation_univ == 'S Origin' || input.transformation_univ == 'S Shaped'",
                     div(style = "margin-top: 15px;",
                         h4("Average Period Selection", class = "section-title"),
                         dateRangeInput("avg_date_range_univ", "Select Date Range for Average:",
                                       start = Sys.Date() - 365,
                                       end = Sys.Date(),
                                       separator = " to ")
                     )
                   ),
                   
                   # Download button
                   div(style = "margin-top: 15px; text-align: center;",
                       downloadButton("download_univariate", "Download Transformed Data", 
                                    class = "btn-primary btn-block custom-download-btn",
                                    icon = icon("download"))
                   )
               )
        ),
        column(width = 9,
               div(class = "section-card",
                   h4("Transformation Settings", class = "section-title"),
                   div(class = "transform-params",
                       div(class = "transform-param-item", numericInput("decay_univ", "Decay", value = 1, min = 0, step = 0.1)),
                       div(class = "transform-param-item", numericInput("lag_univ", "Lag", value = 0, min = 0)),
                       div(class = "transform-param-item", numericInput("maxval_univ", "% MaxVal", value = 100, min = 0, step = 1)),
                       div(class = "transform-param-item", numericInput("alpha_univ", "Alpha", value = 0.85, min = 0, step = 0.01)),
                       div(class = "transform-param-item", numericInput("beta_univ", "Beta", value = 1, min = 0, step = 0.1))
                   )
               ),
               conditionalPanel(condition = "input.transformation_univ == 'S Origin' || input.transformation_univ == 'S Shaped'",
                                div(class = "chart-box",
                                    h4("S-Curve EDA", class = "chart-title"),
                                    plotlyOutput("s_curve_univariate_plot", height = "100%")
                                )
               ),
               conditionalPanel(condition = "!(input.transformation_univ == 'S Origin' || input.transformation_univ == 'S Shaped')",
                                fluidRow(
                                  column(6, div(class = "chart-box", h4("Variable Flighting", class = "chart-title"), plotlyOutput("variable_flighting_chart", height = "300px"))),
                                  column(6, div(class = "chart-box", h4("Transformed Variable", class = "chart-title"), plotlyOutput("var_transf_chart", height = "300px")))
                                )
               ),
               fluidRow(
                 column(4, div(class = "chart-box", h4("Boxplot", class = "chart-title"), plotOutput("boxplot_univ", height = "300px"))),
                 column(4, div(class = "chart-box", h4("Suggested Max Value", class = "chart-title"), verbatimTextOutput("transformations_summary_univ", placeholder = TRUE))),
                 column(4, div(class = "chart-box", h4("KPI vs. Variable Correlation", class = "chart-title"), plotlyOutput("corr_kpi_var_univ", height = "300px")))
               )
        )
      )
    )
  )
}# UI.R

# =============================================================================
# Main interface of the application (UI) with navbarPage and the tabs
# Information, Univariate, Multivariate.
# =============================================================================

# Load the three UI modules
source("R/ui/information_ui.R", local = TRUE)
source("R/ui/univariate_ui.R",   local = TRUE)
source("R/ui/multivariate_ui.R", local = TRUE)

ui <- navbarPage(
  id    = "main-tabs",
  title = NULL,
  theme = shinythemes::shinytheme("flatly"),
  tags$head(
    tags$link(rel = "stylesheet", type = "text/css", href = "styles.css"),
    tags$script(src = "custom.js") # Include custom JavaScript
  ),
  
  # Information tab
  tabPanel(
    "Information",
    ui_information()
  ),
  
  # Univariate tab
  tabPanel(
    "Univariate",
    ui_univariate()
  ),
  
  # Multivariate tab
  tabPanel(
    "Multivariate",
    ui_multivariate()
  )
)
